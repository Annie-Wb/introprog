%!TEX encoding = UTF-8 Unicode
%!TEX root = ../compendium1.tex

\ifPreSolution

\Exercise{\ExeWeekTHREE}\label{exe:W03}
\begin{Goals}
\input{modules/w03-functions-exercise-goals.tex}
\end{Goals}

\begin{Preparations}
\item \StudyTheory{03}
\end{Preparations}

\BasicTasks %%%%%%%%%%%%%%%%

\else

\ExerciseSolution{\ExeWeekTHREE}

\fi





\WHAT{Para ihop begrepp med beskrivning.}

\QUESTBEGIN

\Task \what~Koppla varje begrepp med den (förenklade) beskrivning som passar bäst:

\begin{ConceptConnections}
\input{generated/quiz-w03-concepts-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
\input{generated/quiz-w03-concepts-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND





\WHAT{Definiera och anropa funktioner.}

\QUESTBEGIN

\Task \label{task:funcall} \what~
En funktion med en parameter definieras med följande syntax i Scala:
\vspace{0.5em} \\
\texttt{\code{def} \textit{namn}(\textit{parameter}: \textit{Typ} = \textit{defaultArgument}): \textit{Returtyp} = \textit{returvärde}}

% En funktion med två parametrar definieras med följande syntax i Scala: \vspace{0.5em} \\  \texttt{\code{def} \textit{namn}(\textit{parameter1}: \textit{Typ1}, \textit{parameter2}: \textit{Typ2}): \textit{Returtyp} = \textit{returvärde}}

\Subtask Definiera funktionen \code{öka} som har en heltalsparameter \code{x} och vars returvärde är argumentet plus 1. Defaultargument ska vara 1. Ange returtypen explicit.

\Subtask Vad har uttrycket \code{öka(öka(öka(öka())))} för värde?

\Subtask Definiera funktionen \code{minska} som har en heltalsparameter \code{x} och vars returvärde är argumentet minus 1. Defaultargument ska vara 1. Ange returtypen explicit.

\Subtask Vad är värdet av uttrycket \code{öka(minska(öka(öka(minska(minska())))))}

\Subtask Vad är det för skillnad mellan parameter och argument?

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{Code}
def öka(x: Int = 1): Int = x + 1
\end{Code}

\SubtaskSolved  \code{5}

\SubtaskSolved
\begin{Code}
def minska(x: Int = 1): Int = x - 1
\end{Code}

\SubtaskSolved  \code{1}

\SubtaskSolved
\begin{itemize}
  \item \emph{Kort, förenklad förklaring:} Parametern i funktionshuvudet är ett lokalt namn på indata som kan användas i funktionskroppen, medan argumentet är själva värdet på parametern som skickas med vid anrop.
  \item \emph{Längre, mer exakt förklaring:} En \textbf{parameter} är en deklaration av en oföränderlig variabel i ett funktionshuvud vars namn finns tillgängligt lokalt i funktionskroppen. Vid anrop \emph{binds} parameternamnet till ett specifikt argument. Ett \textbf{argument} är ett uttryck som  appliceras på en funktion vid anrop. Normalt evalueras argumentet innan anropet sker, men om parametertypen föregås av \code{=>} fördröjs evalueringen av argumentet och sker i stället \emph{varje gång} parameternamnet förekommer i funktionskroppen.
\end{itemize}

\QUESTEND



\WHAT{Implementera funktion på olika sätt.}

\QUESTBEGIN

\Task \label{task:funcsumfirst} \what~
Skapa en funktion som kan summera de första \code{n} positiva heltalen.

\Subtask Skriv först funktionshuvudet med \code{???} som funktionskropp. Ge funktionen ett bra namn. Ange returtyp. Kontrollera att din funktion kompilerar utan kompileringsfel innan du går vidare.

\Subtask Implementera funktionen med hjälp av ett intervall och metoden \code{sum}. Testa så att funktionen fungerar. Vad händer om du ger ett negativt argument?

\Subtask Implementera funktionen med hjälp av \code{while}-\code{do}. Vad händer om du ger ett negativt argument?

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{Code}
def sumFirst(n: Int): Int = ???
\end{Code}

\SubtaskSolved
\begin{Code}
def sumFirst(n: Int): Int = (1 to n).sum
\end{Code}
\begin{REPL}
scala> sumFirst(-1)
val res0: Int = 0
\end{REPL}

\SubtaskSolved
\begin{Code}
def sumFirst(n: Int): Int = 
  var result = 0
  var i = 1
  while i <= n do 
    result += i
    i += 1
  end while
  result
end sumFirst
\end{Code}
\begin{REPL}
scala> sumFirst(-1)
val res1: Int = 0
\end{REPL}

\QUESTEND




\WHAT{Textspelet AliensOnEarth.}

\QUESTBEGIN

\Task  \what~Ladda ner spelet nedan \footnote{
\url{https://raw.githubusercontent.com/lunduniversity/introprog/master/compendium/examples/AliensOnEarth.scala}} och studera koden.

\scalainputlisting[basicstyle=\ttfamily\fontsize{10}{12}\selectfont,numbers=left]{examples/AliensOnEarth.scala}

% def randomDistribution(weights: Vector[Int]): Int = {
%   require(weights.size > 0)
%   require(weights.forall(_ >= 0))
%
%   val probabilities = for (w <- weights) yield w / weights.sum.toDouble
%   val rnd = math.random()
%   var i = 0
%   var sum = probabilities(i)
%   while (i < probabilities.size - 1 && rnd > sum) {
%     i += 1
%     sum += probabilities(i)
%   }
%   i
% }

\Subtask Medan du läser koden, försök lista ut vilket som är bästa strategin för att få så mycket poäng som möjligt. Kompilera och kör spelet i terminalen med ditt favoritnamn som argument. Vilket av de tre objekten på planeten jorden har störst sannolikhet att vara bästa alternativet?

\Subtask Para ihop kodsnuttarna nedan med bästa beskrivningen.\footnote{Gör så gott du kan även om allt inte är solklart. Vissa saker kommer vi att gå igenom i detalj först under senare kursmoduler.}

\begin{ConceptConnections}
\input{generated/quiz-w03-code-fragments-taskrows-generated.tex}
\end{ConceptConnections}

\noindent\emph{Tips:} Med hjälp av REPL kan du ta reda på hur olika delar fungerar, t.ex.:

\begin{REPL}
scala> val xs = Vector("p", "w", "a")
scala> xs.indices
scala> xs.indices.foreach(i => println(i))
scala> xs.indexOf("w")
scala> xs.indexOf("gurka")
scala> Vector("hej", "hejsan", "hej").indexOf("hej")
scala> try 1 / 0 catch case e: Exception => println(e)
\end{REPL}
%Kolla även dokumentationen för \code{nextInt}, \code{readLine}, m.fl genom att söka här: \\ \url{http://www.scala-lang.org/api/current/index.html}


%\begin{framed}
\noindent\emph{Tips inför fortsättningen:}

\begin{itemize}[nolistsep]
  \item När jag hittade på \code{AliensOnEarth} började jag med ett mycket litet program med en enkel \code{main}-funktion som bara skrev ut något kul. Sedan byggde jag vidare på programmet steg för steg och kompilerade och testade efter varje liten ändring.

  \item När jag kodar har jag REPL igång i ett eget terminalfönster och min kodeditor i ett annat fönster. I ett tredje fönster har jag en terminal med kompilering i \textit{watch mode}, se appendix \ref{appendix:build-scala-cli-watch-mode}. Fråga en handledare om hur du kan arbeta effektivt med stegvisa experimentering i REPL för att bygga upp ett allt större program i små steg.

  \item Detta arbetssätt tar ett tag att komma in i, men är ett bra sätt att uppfinna allt större och bättre program. Ett stort program byggs lättast i små steg och felsökning blir mycket lättare om man bara gör små tillägg åt gången.

  \item Du får också det mycket lättare att förstå ditt program om du delar upp koden i många korta funktioner med bra namn. Du kan sedan lättare hitta på mer avancerade funktioner genom att återanvända befintliga.

  \item Under veckans laboration ska du utveckla ditt eget textspel. Då har du nytta av att återanvända funktionerna för indata och slumpdragning från exempelprogrammet \code{AliensOnEarth}.
\end{itemize}

%\end{framed}


\SOLUTION

\TaskSolved \what~

\SubtaskSolved \code{"penguin"} är bästa alternativ med sannolikheten $\frac{1}{2} + \frac{1}{2}\cdot\frac{1}{3} = \frac{2}{3}$

\SubtaskSolved

\begin{ConceptConnections}
  \input{generated/quiz-w03-code-fragments-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND



\WHAT{Äkta funktioner.}

\QUESTBEGIN

\Task  \what~  En äkta funktion%
\footnote{Äkta funktioner uppfyller per definition  \textit{referentiell transparens} \Eng{referential transparency} som du kan läsa mer om här:  \href{https://simple.wikipedia.org/wiki/Referential_transparency}{simple.wikipedia.org/wiki/Referential\_transparency}}
\Eng{pure function} ger alltid samma resultat med samma argument (så som vi är vana vid inom matematiken) och har inga externt observerbara sidoeffekter (till exempel utskrifter).

Vilka funktioner nedan är äkta funktioner?
\begin{Code}
var x = 0
val y = x

def inc(i: Int) = i + 1

def nöff(i: Int) = 
  x = x + i
  "nöff " * x
end nöff

def addX(i: Int) = x + i

def addY(i: Int) = y + i

def isPalindrome(s: String) = s == s.reverse

def rnd(min: Int, max: Int) = math.random() * max + min
\end{Code}


\noindent\emph{Tips:} Skriv av och testa funktionerna i REPL en och en, så att du förstår exakt vad som händer.

\SOLUTION

\TaskSolved \what

\begin{itemize}
  \item Funktionerna  \code{inc}, \code{addY} och \code{isPalindrome} är äkta. Notera att \code{y}-variablen initialiseras till \code{0} och kan sedan inte ändras eftersom den är deklarerad med nyckelordet \code{val}.
\end{itemize}

\QUESTEND


\WHAT{Applicera funktion på varje element i en samling. Funktion som argument.}

\QUESTBEGIN

\Task  \what~

\noindent Deklarera funktionen \code{öka} och variabeln \code{xs} enligt nedan i REPL:
\begin{REPL}
scala> def öka(x: Int) = x + 1
scala> val xs = Vector(3, 4, 5)
\end{REPL}
\noindent Para ihop nedan uttryck till vänster med det uttryck till höger som har samma värde. Om du undrar något, testa uttrycken och olika varianter av dem i REPL.

\begin{ConceptConnections}
\input{generated/quiz-w03-yield-map-taskrows-generated.tex}
\end{ConceptConnections}

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
  \input{generated/quiz-w03-yield-map-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND




\WHAT{Anonyma funktioner.}

\QUESTBEGIN

\Task  \what~  Vi har flera gånger sett syntaxen \code{i => i + 1}, till exempel i en loop \code{(1 to 10).map(i => i + 1)} där funktionen \code{i => i + 1} appliceras på alla heltal från 1 till och med 10 och resultatet blir en ny sekvenssamling.

Syntaxen \code{(i: Int) => i + 1} är en litteral för att skapa ett \emph{funktionsvärde} (kallas även \emph{anonym funktion} eller \emph{lambda-uttryck}). Syntaxen liknar den för funktionsdeklarationer, men nyckelordet \code{def} saknas i funktionshuvudet och i stället för likhetstecken används \code{=>} för att avskilja parameterlistan från funktionskroppen.
Om kompilatorn kan härleda typen ur sammanhanget kan kortformen \code{i => i + 1} användas.

Det finns ett \emph{ännu} kortare sätt att skriva en anonym funktion \emph{om} typen kan härledas \emph{och} den bara använder sin parameter \emph{en enda gång}; då går funktionslitteraler att skriva med s.k. \emph{platshållarsyntax} som använder understreck, till exempel \code{ _ + 1} och som automatiskt expanderas av kompilatorn till \code{ngtnamn => ngtnamn + 1} (namnet på parametern spelar ingen roll; kompilatorn väljer något eget, internt namn).

Para ihop uttryck till vänster med uttryck till höger som har samma värde:

\begin{ConceptConnections}
\input{generated/quiz-w03-lambda-taskrows-generated.tex}
\end{ConceptConnections}

\noindent
Funktionslitteraler kallas \textit{anonyma funktioner}, eftersom de inte har något namn, till skillnad från t.ex. \code{def öka(i: Int): Int = i + 1}, som ju heter \code{öka}. Ett annat vanligt namn är \textit{lambda-uttryck} efter det datalogiska matematikverktyget \href{https://sv.wikipedia.org/wiki/Lambdakalkyl}{lambdakalkyl}.

\SOLUTION

\TaskSolved \what

\begin{ConceptConnections}
  \input{generated/quiz-w03-lambda-solurows-generated.tex}
\end{ConceptConnections}

\QUESTEND




\WHAT{Skapa din egen kontrollstruktur med hjälp av namnanrop.}\label{func:upprepa}

\QUESTBEGIN

\Task  \what~Namnanrop skrivs med en raket efter kolon före parametertypen och innebär att argumentet evalueras på plats varje gång.

\Subtask Använd namnanrop i kombination med en uppdelad parameterlista och skapa din egen kontrollstruktur enligt nedan.\footnote{Det är så loopen \code{upprepa} i Kojo är definierad.}
\begin{Code}
def upprepa(n: Int)(block: => Unit): Unit =
  var i = 0
  while i < n do 
    ???
  end while
\end{Code}

\Subtask
Testa din kontrollstruktur i REPL. Låt upprepa 100 gånger att ett slumptal mellan 1 och 6 dras och sedan skrivs ut. Prova även att använda färre klammerparenteser med hjälp av kolon.

\Subtask
Varför behövs namnanrop här?

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{Code}
def upprepa(n: Int)(block: => Unit): Unit =
  var i = 0
  while i < n do
    block
    i += 1
  end while
\end{Code}

\SubtaskSolved
\begin{Code}
upprepa(100):
  val tärningskast = (math.random() * 6 + 1).toInt
  print(s"\$tärningskast ")
\end{Code}

\SubtaskSolved Om parametern \code{block} inte vore deklarerad med namnanrop så hade argumentet evaluerats en gång innan anropet och sedan hade det blivit samma resultat vid varje iteration. Med namnanrop kan block innehålla kod som t.ex. uppdaterar en variabel som vi vill ska ske vid varje iteration. Namn-anrop liknar att koden för argumentet ''klistras in'' på varje plats i funktionskroppen där parameternamnet förekommer. 

\QUESTEND



\WHAT{Lär dig läsa en stack trace.}

\QUESTBEGIN

\Task  \what~  Skriv ett program i filen \texttt{fel.scala} som orsakar ett \emph{körtidsfel} och kör igång det i terminalen med \code{scala-cli run fel.scala}. Studera den stack trace som skrivs ut. Vad innehåller en \code{stack trace}? Diskutera med handledare hur du kan ha nytta av en stack trace när du felsöker.

\SOLUTION

\TaskSolved \what En stack trace innehåller följande information:
\begin{enumerate}
  \item ett felmeddelande
  \item namn på alla funktioner som anropats vid tiden för körtidsfelet, enligt alla aktiveringsposter som ligger på anropsstacken 
  \item aktuell namnrymnd för varje funktionen, alltså paket/singelobjekt
  \item namnet på kodfilen för varje funktion
  \item radnummer i varje funktion 
  \item den funktion som kommer först är den funktion där felet inträffade
  \item eventuellt kan felet inträffa i standardbibliotekets funktioner och då är din egen funktion tidigare i anropskedjan
\end{enumerate}

Exempel på en stack trace:
\begin{REPLnonum}
> cat fel.scala 
@main def run = 
  println("Hej Scala!" + Vector().head)
> scala-cli run fel.scala
Compiling project (Scala 3.3.0, JVM)
Compiled project (Scala 3.3.0, JVM)
Exception in thread "main" java.util.NoSuchElementException: empty.head
	at scala.collection.immutable.Vector.head(Vector.scala:279)
	at fel$package$.run(fel.scala:2)
	at run.main(fel.scala:1)
>
\end{REPLnonum}

\QUESTEND


\ExtraTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\WHAT{Funktion med flera parametrar.}

\QUESTBEGIN

\Task  \what~  

\Subtask Definiera i REPL två funktioner \code{sum} och \code{diff} med två heltalsparametrar som returnerar summan respektive differensen av argumenten:
\begin{Code}
def sum(x: Int, y: Int): Int = ???

def diff(x: Int, y: Int): Int = ???
\end{Code}
Vad har nedan uttryck för värden? Förklara vad som händer.

\Subtask \code{diff(0, 100)}

\Subtask \code{diff(100, sum(42, 43))}

\Subtask \code{sum(sum(42, 43), diff(100, sum(0, 0)))}

\Subtask \code{sum(diff(Byte.MaxValue, Byte.MinValue), 1)}

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{Code}
  def sum(x: Int, y: Int): Int = x + y
  
  def diff(x: Int, y: Int): Int = x - y
\end{Code}
  

\SubtaskSolved  Det blir \code{-100} efter som \code{0 - 100 == -100} 

\SubtaskSolved  Det blir \code{15} eftersom det nästlade anropet motsvarar \\\code{diff(100, 42 + 43) == (100 - 85)}

\SubtaskSolved  Det blir \code{185} eftersom det nästlade anropet motsvarar \\\code{sum(42 + 43, 100 - 0) == (85 + 100)}

\SubtaskSolved  Det blir \code{256} eftersom \code{Byte.MaxValue == 127} och \  code{Byte.MinValue == -128} och \code{sum(127 + 128, 1) == 256}

\QUESTEND



\WHAT{Medelvärde.}

\QUESTBEGIN

\Task  \what~ Skriv och testa en funktion \code{avg} som räknar ut medelvärdet mellan två heltal och returnerar en \code{Double}.

\SOLUTION

\TaskSolved \what

\begin{Code}
def avg(x: Int, y: Int): Double = (x + y) / 2.0
\end{Code}

\QUESTEND




\WHAT{Funktionsanrop med namngivna argument.}

\QUESTBEGIN

\Task  \what~
\begin{REPL}
scala> def skrivNamn(efternamn: String, förnamn: String) =
         println(s"Namn: $efternamn, $förnamn")
scala> skrivNamn(förnamn = "Stina", efternamn = "Triangelsson")
scala> skrivNamn(efternamn = "Oval", "Viktor")

\end{REPL}

\Subtask Vad skrivs ut efter rad 3 resp. rad 4 ovan?

\Subtask Nämn tre fördelar med namngivna argument.

\SOLUTION

\TaskSolved \what~

\SubtaskSolved
\begin{REPL}
Namn: Triangelsson, Stina
Namn: Oval, Viktor
\end{REPL}

\SubtaskSolved
\begin{itemize}
  \item Anroparen kan själv välja ordning.
  \item Koden blir lättare att begripa om parameternamnen är självbeskrivande.
  \item Hjälper till att förhindra buggar som beror på förväxlade parametrar.
\end{itemize}

\QUESTEND



\WHAT{Funktion som äkta värde.}

\QUESTBEGIN

\Task  \what~  Funktioner är \emph{äkta värden} i Scala%\footnote{I likhet med t.ex. Javascript, men till skillnad från t.ex. Java.}
. Det betyder att variabler kan ha funktioner som värden och funktionsvärden kan vara argument till funktioner som har funktionsparametrar. Funktioner som tar funktioner som argument kallas \emph{högre ordningens funktioner}.

En funktion som har en heltalsparameter och ett heltalsresultat är av funktionstypen \code{Int => Int} (uttalas \emph{int-till-int}) och värdet av funktionen utgör ett objekt som har en metod som heter \code{apply} med motsvarande funktionstyp.

\Subtask \label{subtask:funcval} Deklarera nedan funktioner och variabler i REPL. Para sedan ihop nedan uttryck till vänster med det uttryck till höger som skapar samma utskrift. Om du undrar något, testa uttrycken och olika varianter av dem i REPL.

\begin{REPL}
scala> def hälsa(): Unit = println("Hej!")
scala> def fleraAnrop(antal: Int, f: () => Unit): Unit =
         for _ <- 1 to antal do f()
scala> val f1 = () => hälsa()
scala> var f2 = (s: String) => println(s)
scala> val f3 = () => f2("Thunk")
\end{REPL}

\begin{ConceptConnections}
\input{generated/quiz-w03-function-values-taskrows-generated.tex}
\end{ConceptConnections}


\Subtask Vilka typer har variablerna \code{f1}, \code{f2} och \code{f3}?

\Subtask Funkar detta? Varför? \code{f2 = f1}

\Subtask Funkar detta? Varför? \code{val f4 = fleraAnrop}

\Subtask Funkar detta? Varför? \code{val f4 = hälsa}

\Subtask Funkar detta? Varför? \code{val f4: () => Unit = hälsa}

\SOLUTION

\TaskSolved \what

\SubtaskSolved

\begin{ConceptConnections}
  \input{generated/quiz-w03-function-values-solurows-generated.tex}
\end{ConceptConnections}

\SubtaskSolved \code{f1} och \code{f3} är av typen \code{() => Unit} och \code{f2} av typen \code{String => Unit}.

\SubtaskSolved  Nej. \code{f1} och \code{f2} är av två olika funktionstyper.

\SubtaskSolved  Ja, det går fint.

\SubtaskSolved  Nej. När funktionen inte har någon parameter behöver kompilatorn mer information för att vara säker på att det är ett funktionsvärde du vill ha.

\SubtaskSolved Ja! Nu med typinformationen på plats är kompilatorn säker på vad du vill göra.

\QUESTEND



\WHAT{Bortkastade resultatvärden och returtypen \code{Unit}.}

\QUESTBEGIN

\Task  \what~ Undersök nedan kod i REPL och förklara vad som händer.

\Subtask
\begin{REPL}
scala> def tom = println("")
scala> println(tom)
\end{REPL}

\Subtask
\begin{REPL}
scala> def bortkastad: Unit = 1 + 1
scala> println(bortkastad)
\end{REPL}

\Subtask
\begin{REPL}
scala> def bortkastad2 = { val x = 1 + 1 }
scala> println(bortkastad2)
\end{REPL}

\Subtask Varför är det bra att explicit ange \code{Unit} som returtyp för procedurer?

\SOLUTION

\TaskSolved \what

\SubtaskSolved Procedurer returnerar tomma värdet och \code{println} är en procedur. När tomma värdet skrivs ut visas \code{()}.

\SubtaskSolved Procedurer returnerar tomma värdet. Om du anger returtyp \code{Unit} explicit, har du bättre chans att kompilatorn kan ge varning då uträkningar kommer att kastas bort. En varning avbryter inte exekveringen, utan är ett sätt för kompilatorn att ge dig tips om saker som kan behöva fixas till i din kod.

\SubtaskSolved I Scala är variabeldeklaration, precis som en tilldelningssats, och inte ett uttryck och saknar värde.

\SubtaskSolved  Koden blir lättare att läsa och kompilatorn får bättre möjlighet att hjälpa till med varningar om resultatvärden riskerar att bli bortkastade.

\QUESTEND


\WHAT{Namnanrop.}

\QUESTBEGIN

\Task  \what~

Deklarera denna procedur i REPL:
\begin{Code}
def görDettaTvåGånger(b: => Unit): Unit = { b; b }
\end{Code}

Anropa \code{görDettaTvåGånger} med ett block som parameter. Blocket ska innehålla en utskriftssats. Förklara vad som händer.

\SOLUTION

\TaskSolved \what

Blocket är ett uttryck som har värdet \code{(): Unit}. Evalueringen av blocket sker där namnet \code{b} förekommer i procedurkroppen, vilket är två gånger.
\begin{REPL}
scala> görDettaTvåGånger { println("goddag") }
goddag
goddag
\end{REPL}

\QUESTEND




\clearpage

\AdvancedTasks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\WHAT{Föränderlighet av parametrar.}

\QUESTBEGIN

\Task \what~Vad tror du om detta: Är en parameter förändringsbar i funktionskroppen ...

\Subtask ... i Scala?  (Ja/Nej)

\Subtask ... i Java?  (Ja/Nej)

\Subtask ... i Python?  (Ja/Nej)


\SOLUTION

\TaskSolved \what~

\Subtask Nej, i Scala är parametern oföränderlig och det blir kompileringsfel om man försöker tilldela den ett nytt värde i funktionskroppen.

\Subtask \Subtask Ja det går utmärkt i både Java och Python att ändra värdet på parametern i funktionskroppen med tilldelning, men koden riskerar att bli förvirrande.\\
\url{https://stackoverflow.com/questions/2970984}

\QUESTEND



\WHAT{Värdeanrop och namnanrop.}

\QUESTBEGIN

\Task  \what~Normalt sker i Scala (och i Java) s.k. \emph{värdeanrop} vid anrop av funktioner, vilket innebär att argumentuttrycket evalueras \emph{före} bindningen till parameternamnet sker.

Man kan också i Scala (men inte i Java) med syntaxen \code{=>} framför parametertypen deklarera att \emph{namnanrop} ska ske, vilket innebär att evalueringen av argumentuttrycket \emph{fördröjs} och sker \emph{varje gång} namnet används i metodkroppen.

Deklarera nedan funktioner i REPL.

\begin{Code}
def snark: Int = { print("snark "); Thread.sleep(1000); 42 }
def callByValue(x: Int):   Int = x + x
def callByName(x: => Int): Int = x + x
lazy val zzz = snark
\end{Code}

\noindent Förklara vad som händer när nedan uttryck evalueras.

\Subtask \code{snark + snark}

\Subtask \code{callByValue(snark)}

\Subtask \code{callByName(snark)}

\Subtask \code{callByName(zzz)}

\SOLUTION

\TaskSolved \what

\SubtaskSolved Vid varje anrop av \code{snark} sker en utskrift och en fördröjnig innan $42$ returneras. \\\code{42 + 42 == 84} vilket blir värdet av uttrycket.
\begin{REPL}
scala> snark + snark
snark snark val res1: Int = 84
\end{REPL}

\SubtaskSolved Uttrycket \code{snark} evalueras direkt vid anropet och parametern \code{x} binds till värdet $42$ och i funktionskroppen beräknas $42+42$. Utskriften sker bara en gång.
\begin{REPL}
callByValue(snark)
snark val res2: Int = 84
\end{REPL}

\SubtaskSolved Evalueringen av uttrycket \code{snark} fördröjs tills varje förekomst av parametern \code{x} i funktionskroppen. Utskriften sker två gånger.
\begin{REPL}
callByName(snark)
snark snark val res3: Int = 84
\end{REPL}

\SubtaskSolved Evalueringen av uttrycket \code{zzz} fördröjs tills varje förekomst av parametern \code{x} i funktionskroppen. Utskriften sker en gång eftersom \code{val}-variabler tilldelas sitt värde en gång för alla vid den fördröjda initialiseringen.
\begin{REPL}
callByName(zzz)
snark val res4: Int = 84
\end{REPL}

\QUESTEND



\WHAT{Skapa egen kontrollstruktur för iteration med loop-variabel.}

\QUESTBEGIN

\Task  \what~

\Subtask Fördelen med \code{upprepa} i uppgift \ref{func:upprepa} är att den är koncis och lättanvänd. Men den är inte lika lätt att använda om man behöver tillgång till en loopvariabel. Implementera därför nedan kontrollstruktur.

\begin{Code}
def repeat(n: Int)(p: Int => Unit): Unit = 
  var i = 0
  while i < n do
    ??? 
\end{Code}

\Subtask Använd \code{repeat} för att 100 gånger skriva ut loopvariabeln och ett slumpdecimaltal mellan 0 och 1.


\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{Code}
def repeat(n: Int)(p: Int => Unit): Unit = 
  var i = 0
  while i < n do
    p(i)
    i += 1
  end while
end repeat
\end{Code}

\SubtaskSolved

\begin{Code}
repeat(100){ i =>
  print("i ")
  println(math.random())
}
\end{Code}
Du kan använda färre klammerparenteser med hjälp av kolon:
\begin{Code}
repeat(100): i =>
  print("i ")
  println(math.random())
\end{Code}

\QUESTEND






\WHAT{Uppdelad parameterlista och stegade funktioner.}

\QUESTBEGIN

\Task \what~Man kan dela upp parametrarna till en funktion i flera parameterlistor. Funktionen \code{add1} nedan har en parameterlista med två parametrar medan \code{add2} har två parameterlistor med en parameter vardera:
\begin{Code}
  def add1(a: Int, b: Int) = a + b
  def add2(a: Int)(b: Int) = a + b
\end{Code}

\Subtask  När man anropar funktionen \code{add2} ska argumenten skrivas inom två olika parentespar. Hur kan du använda \code{add2} för att räkna ut \code{1 + 1}?

\Subtask En fördel med uppdelade parameterlistor är att man kan skapa s.k. \emph{stegade funktioner}\footnote{Kallas även Curry-funktioner efter matematikern och logikern Haskell Brooks Curry.} där argumenten är partiellt applicerade. Prova det stegade funktionsvärdet \code{singLa} nedan. Vad skrivs ut på efter raderna 3 och 5?

\begin{REPL}
scala> def repeat(s: String)(n: Int): String = s * n
scala> val song = repeat("doremi ")(3)
scala> println(song)
scala> val singLa = repeat("la")
scala> println(singLa(7))
\end{REPL}

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\begin{REPL}
scala> def add2(a: Int)(b: Int) = a + b
def add2(a: Int)(b: Int): Int

scala> add2(1)(1)
val res0: Int = 2
\end{REPL}

\SubtaskSolved
\begin{itemize}

\item Rad 3:
\begin{REPLnonum}
doremi doremi doremi 
\end{REPLnonum}

\item Rad 5:
\begin{REPLnonum}
lalalalalalala
\end{REPLnonum}

\end{itemize}


\QUESTEND




\WHAT{Rekursion.}

\QUESTBEGIN

\Task\Uberkurs  \what~  En rekursiv funktion anropar sig själv.

\Subtask Förklara vad som händer nedan.

\begin{REPL}
scala> def countdown(x: Int): Unit = 
         if x > 0 then {println(x); countdown(x - 1)}
scala> countdown(10)
scala> countdown(-1)
scala> def finalCountdown(x: Byte): Unit =
         {println(x); Thread.sleep(100); finalCountdown((x-1).toByte); 1 / x}
scala> finalCountdown(Byte.MaxValue)
\end{REPL}

\Subtask Vad händer om du gör satsen som riskerar division med noll \emph{före} det rekursiva anropet i funktionen \code{finalCountdown} ovan?

\Subtask Förklara vad som händer nedan. Varför tar sista raden längre tid än näst sista raden?
\begin{REPL}
scala> def signum(a: Int): Int = if a >= 0 then 1 else -1
scala> def add(x: Int, y: Int): Int =
         if y == 0 then x else add(x + 1, y - signum(y))
scala> add(100, 100)
scala> add(Int.MaxValue, 0)
scala> add(0, Int.MaxValue)
\end{REPL}

\SOLUTION

\TaskSolved \what

\SubtaskSolved
\code{countdown} skriver ut x och gör ett rekursivt anrop med \code{x - 1} som argument, men bara om basvillkoret \code{x > 0} är uppfyllt. Resultatet blir en ändlig  repetition.
\code{finalCountdown} anropar sig själv rekursivt men saknar ett basvillkor som kan avbryta rekursionen, vilket genererar en oändlig repetition. Vid -128 blir det \emph{overflow} eftersom bitarna inte räcker till för större negativa tal och räkningen börjar om på 127. (Om minskar fördröjningen till \code{Thread.sleep(1)} blir det ganska snabbt \emph{stack overflow})

\SubtaskSolved
Eftersom vi hade \code{1/x} \emph{efter} det rekursiva anropet i föregående deluppgift, så kom vi aldrig till denna (potentiellt ödesdigra) beräkning, utan lade bara aktiveringsposter på hög på stacken vid varje anrop. Om vi placerar \code{1/x} \emph{före} det rekursiva anropet, så når vi detta uttryck direkt och det kastas ett undantag p.g.a. division med noll.

\SubtaskSolved
Den sista raden leder till många fler rekursiva anrop, så som basvillkoret och det rekursiva anropet är konstruerade. Lägg gärna in en \code{println}-sats före det rekursiva anropet och undersök i detalj vad som sker.

\QUESTEND



\WHAT{Undersök svansrekursion genom att kasta undantag.}

\QUESTBEGIN

\Task\Uberkurs  \what~  Förklara vad som händer. Kan du hitta bevis för att kompilatorn kan optimera rekursionen till en vanlig loop?

\begin{REPL}
scala> def explode = throw Exception("BANG!!!")
scala> explode
scala> def countdown(n: Int): Unit =
         if n == 0 then explode else countdown(n-1)
scala> countdown(10)
scala> countdown(10000)
scala> def countdown2(n: Int): Unit =
         if n == 0 then explode else {countdown2(n-1); print("no tailrec")}
scala> countdown2(10)
scala> countdown2(10000)
\end{REPL}

\SOLUTION

\TaskSolved \what~\code{countdown} är svansrekursiv eftersom det rekursiva anropet står \emph{sist} och kan då optimeras till en \code{while}-loop av kompilatorn. Det går fint att köra ända till det exploderar, även med 10000 anrop, och i felmeddelandet finns det endast ett anrop till \code{countdown}.

\code{countdown2} är inte svansrekursiv eftersom den har ett uttryck \code{efter} det rekursiva anropet. I felutskriften syns alla rekursiva anrop till \code{countdown2} innan basvillkoret inträffade. Vid \code{countdown2(10000)} uppfylls inte basvillkoret innan det blir \code{StackOverflowError}.

\QUESTEND



\WHAT{\code{@tailrec}-annotering.}

\QUESTBEGIN

\Task\Uberkurs  \what~  Du kan be kompilatorn att ge felmeddelande om den inte kan optimera koden till en motsvarande while-loop. Detta kan användas i de fall man vill vara helt säker på att kompilatorn kan optimera koden och det inte kan finnas risk för en överfull stack \Eng{stack overflow} på grund av för djup anropsnästling.

Prova nedan rader i REPL och förklara vad som händer.
\begin{REPL}
scala> def countNoTailrec(n: Long): Unit =
         if n <= 0L then println("Klar! " + n) else {countNoTailrec(n-1L); ()}
scala> countNoTailrec(1000L)
scala> countNoTailrec(100000L)
scala> import scala.annotation.tailrec
scala> @tailrec def countNoTailrec(n: Long): Unit =
         if n <= 0L then println("Klar! " + n) else {countNoTailrec(n-1L); ()}
scala> @tailrec def countTailrec(n: Long): Unit =
         if n <= 0L then println("Klar! " + n) else countTailrec(n-1L)
scala> countTailrec(1000L)
scala> countTailrec(100000L)
scala> countTailrec(Int.MaxValue.toLong * 2L)
\end{REPL}

\SOLUTION

\TaskSolved \what~Första gången \code{countNoTailrec(100000L)} anropas blir det \code{StackOverflowError}. Med annoteringen \code{@tailrec} får vi ett kompileringsfel eftersom kompilatorn inte kan optimera en icke svansrekursiv funktion. Om funktionen skrivs om kan kompilatorn optimera funktionen så att rekursionen byts ut mot en \code{while}-loop och vi kan köra så länge vi orkar utan att stacken flödar över. Och himla snabbt går det!!

\QUESTEND
