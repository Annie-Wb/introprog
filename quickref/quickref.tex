\documentclass[article, a5paper]{memoir}

\def\mydate{\leavevmode\hbox{\the\year-\twodigits\month-\twodigits\day}}
\def\twodigits#1{\ifnum#1<10 0\fi\the#1}

\newcommand{\Version}{Compiled \mydate }

\let\footruleskip\undefined\usepackage{fancyhdr}% http://ctan.org/pkg/fancyhdr

\usepackage{pgfpages}
\pgfpagesuselayout{resize to}[a4paper]

% Swedish.
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage[swedish]{babel}
\usepackage{microtype}


%%% FONT PACKAGES
%\usepackage[sc]{mathpazo}
%\usepackage[varg]{txfonts}
%\usepackage{times}
%\usepackage{tgtermes}% clone of times
%\usepackage[sfdefault,condensed]{cabin}
\usepackage{PTSansNarrow}\renewcommand*\familydefault{\sfdefault}
%\usepackage{tgcursor}
\usepackage[scaled=0.85]{beramono} % inconsolata or beramono ???
%\usepackage{fouriernc} % serif: new century schoolbook
%\usepackage{avant}     % sans serif: Avant Garde


% Typeblock size, margins.
\settypeblocksize{190mm}{127mm}{*}
\setlrmargins{10.5mm}{*}{*}
\setulmargins{10.0mm}{*}{*}
\setheadfoot{0.1pt}{0.1pt}
\checkandfixthelayout

\usepackage{multicol} \setlength{\columnsep}{5mm}
\usepackage{xcolor}
\usepackage{array}

\definecolor{commentgreen}{rgb}{0,0.4,0}
\definecolor{grammarcolor}{rgb}{0.3,0.6,0.1}
\definecolor{mylinkcolor}{rgb}{0,0.1,0.5}
\definecolor{myemphcolor}{rgb}{0,0.4,0.1}
\definecolor{myalertcolor}{rgb}{0.4,0.1,0}
\definecolor{eclipsepurple}{rgb}{0.5,0,0.25}
\definecolor{eclipseblue}{rgb}{0.16,0,1.0}
\definecolor{eclipsegreen}{rgb}{0,0.5,0}


\newcommand{\OptL}{\textbf{\textcolor{grammarcolor}{~[~}}}
\newcommand{\OptR}{\textbf{\textcolor{grammarcolor}{~]~}}}
\newcommand{\RepL}{\textbf{\textcolor{grammarcolor}{~(~}}}
\newcommand{\RepR}{\textbf{\textcolor{grammarcolor}{~)~}}}
\newcommand{\Or}{\textbf{\textcolor{grammarcolor}{~|~}}}


%---------------------------------------------------------------

\newcommand{\LangColor}{red}

\setlength{\parindent}{0pt}
\raggedright
\raggedbottom
\linespread{0.90}\selectfont
\pagestyle{empty}

\newcommand{\mc}[1]{\multicolumn{2}{l}{\hspace{-0.65em}\parbox[t]{102mm}{\small #1}}}

\newcommand{\ind}{\hspace*{1.5em}}

\newcommand{\head}[1]{{\bfseries {\color{\LangColor}{#1}}\par\vspace{1mm}\hrule\vspace{-2mm}}}

\newenvironment{etab}%
{\begin{ctabular}{@{}>{\raggedright\small}p{25mm} @{}>{\raggedright\small}p{45mm} @{}>{\raggedright\arraybackslash\small}p{57mm}}}
{\end{ctabular}}%


\newcommand{\secend}{\\[1mm]}
\newcommand{\subsecend}{\\ \\[-2mm]}
\renewcommand{\arraystretch}{0.9}

% -----------
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{shapes.geometric, shapes.symbols, arrows, matrix, shapes, positioning}
%https://www.sharelatex.com/blog/2013/08/29/tikz-series-pt3.html
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width=3cm, minimum height=1cm,text centered, draw=black, fill=red!30]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=1cm, minimum height=1cm, text=white, text centered, draw=black, fill=blue!50!violet]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text=white, text centered, draw=black, fill=red!50!black]
\tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]
%UML definitions
\tikzstyle{umlclass}=[rectangle, draw=black,  thick, anchor=north, text width=3cm, rectangle split, rectangle split parts = 3]
\tikzstyle{umlarrow}=[->, >=open triangle 90, thick]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% lingstings specifics:
\usepackage{listings}
\usepackage{upquote} %http://tex.stackexchange.com/questions/145416/how-to-have-straight-single-quotes-in-lstlistings
\lstdefinelanguage{Scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,enum,export,extends,false,final,finally,%
    for,forSome,given,if,implicit,import,lazy,match,%
    new,null,object,override,package,%
    private,protected,return,sealed,%
    super,then,this,throw,trait,true,try,%
    type,val,var,while,with,yield,%
    as, derives, end, extension, infix, inline, opaque, open, transparent, using}, % soft keywords
  otherkeywords={=>,<-,<:,>:,@,=>>,?=>},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}


\lstset{
    language=Scala,
    tabsize=2,
    basicstyle=\ttfamily\selectfont,
    keywordstyle=\bfseries\textcolor{eclipsepurple},
    commentstyle=\textcolor{commentgreen},
    numberstyle={\footnotesize},
    numbers=none,
    %backgroundcolor=\textcolor{gray!15},
    frame=none,
    rulecolor=\color{black!25},
    %title={\footnotesize\lstname},
    breaklines=false,
    breakatwhitespace=false,
    framextopmargin=2pt,
    framexbottommargin=2pt,
    showstringspaces=false,
    columns=fullflexible,keepspaces
}
\lstset{literate=%
{Å}{{\AA}}1
{Ä}{{\"A}}1
{Ö}{{\"O}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{å}{{\aa}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{æ}{{\ae}}1
{ø}{{\o}}1
{Æ}{{\AE}}1
{Ø}{{\O}}1
{`}{{\`{}}}1
{─}{{\textemdash}}1
{└}{{|}}1
{├}{{|}}1
{│}{{|}}1
}

\newcommand{\code}{\lstinline[basicstyle=\ttfamily]}
\newcommand{\jcode}{\lstinline[basicstyle=\ttfamily,language=Java]}

\lstnewenvironment{Code}[1][]{%
    \lstset{basicstyle=\ttfamily\fontsize{9}{11}\selectfont,#1}%
}{}

%*****************************************************************



\newcommand{\LangRect}[5]{\tikz[overlay, remember picture,inner sep=7pt,minimum height=0.65cm] \node[fill=#2,text=white,rotate=90] at #4 (name) {\large\normalfont\textbf{#1} ~~{\small \thepage(#5)}}; }

\newcommand{\LangRectOdd}[4]{\LangRect{#1}{#2}{#3}{($(current page.north east)-(0.35,#3)$)}{#4}}
\newcommand{\LangRectEven}[4]{\LangRect{#1}{#2}{#3}{($(current page.north west)-(-0.35,#3)$)}{#4}}


\newcommand{\LangMarker}[3]{%param 1 = language, param 2 = offset from top
%\fancyhead{} % clear all header fields
\fancyfoot{} % clear all footer fields
%\fancyfoot[RO]{\thepage}
%\fancyfoot[LE]{\thepage}
\fancyhead{
\ifodd\thepage\LangRectOdd{#1}{\LangColor}{#2}{#3}
\else\LangRectEven{#1}{\LangColor}{#2}{#3}
\fi
}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\pagestyle{fancy}
}

\newcommand{\Newline}{\vspace{\baselineskip}}

\newcommand{\LangTitle}[1]{{\centering \Huge{\bfseries\sffamily \color{\LangColor}{#1}}\par}}

\newcommand{\Comment}[1]{{\color{commentgreen}{#1}}}

\begin{document}
\LangMarker{Scala}{1.5cm}{12}
\LangTitle{ \vspace*{-1.0em} Scala 3.4 Quick Ref @ Lund University}
{\centering https://github.com/lunduniversity/introprog/tree/master/quickref \\
{\small \Version. License: CC-BY-SA. Pull requests welcome! Contact: bjorn.regnell@cs.lth.se}\\
%{\small Pull requests welcome! Contact: bjorn.regnell at cs.lth.se}
\par}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{0.6em}
\head{Compile and run @main program} \vspace{0.8em}
\hspace{0.32em}\begin{minipage}{0.56\linewidth}%
%Example source file \code{hi.scala} with top-level definitions: 
\vspace{-0.75em}
\begin{Code}
//> using scala 3.4.2
//> using toolkit default
//> using dep se.lth.cs::introprog:1.4.0
\end{Code}%
\vspace*{-0.9em}
\begin{Code}
package x.y.z
import introprog.Dialog.{file as selectFile}

val greeting = "Hej "

def greet(nbr: Int, names: Seq[String]) =
  names.mkString(greeting * nbr, ", ", "\n")

@main def RunGreet(n: Int, xs: String*) =
  val dir = os.pwd.toString
  val f = selectFile(startDir = dir)
  if f.nonEmpty && !os.exists(os.Path(f)) 
  then os.write(os.Path(f), greet(n, xs))
  else println("ERROR: greeting aborted")
\end{Code}%
\end{minipage}%
\hfill\begin{minipage}{0.40\linewidth}
\raggedright{\small\vspace{0.2em}
A compilation unit, e.g. \code{hi.scala}, can have top-level definitions such as val, var, def, import, class and object, which may be preceded by a package clause, e.g.: \code|package x.y.z | creates a name space and places the compiled bytecode in dir \code{.scala-build} under  \code{x/y/z/}\\[0.5em]

\textbf{Compile and run single file:}
\verb|scala-cli run hi.scala|\\[0.2em]
\textbf{Compile all scala \& java files in current dir:}\\
\verb|scala-cli compile . -w|\\
where \code{-w} or \code{--watch} recompile on change\\
the dot \code{.} gives access to code in current dir.
\\[0.2em]
\textbf{Run all scala \& java files in current dir:}\\
\verb|scala-cli run . -- 42 Sara Jim|\\Main program arguments after \code{--} 
\\[0.2em]
\textbf{Start REPL:} ~\verb|scala-cli repl .|\\[0.2em]
\hfill

%\begin{tabular}{@{}r @{\hspace{0.5em}}l} \\[-0.5em]
%\textbf{Compile}:  & \verb|scala-cli compile hi.scala| \\
%\textbf{Run}:  &  \verb|scala-cli run . -- Ada Joe| \\[0.1em]
%&Execution starts in method marked \verb|@main|.
%&\end{tabular}%
}%
\end{minipage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{-0.5em}
\head{Definitions and declarations}\Newline
{\small\renewcommand{\arraystretch}{0.95}
A \textbf{definition} binds a name to a value/implementation, while a \textbf{declaration} just introduces a name (and type) of an abstract member. Below \code|defsAndDecl| denotes a list of definitions and/or declarations. Template bodies \code|{ ... }| are optional, can be replaced by \code{:} that opens an indentation region.~~~ \code{=}~~also opens an indentation region
\newcommand{\MoveUp}{\\[-0.9em]}
\newcommand{\FirstColWidth}{0.65cm}
\begin{tabular}{@{}p{\FirstColWidth} l l}\\
%\textbf{What} & \textbf{Example} & \textbf{Exlpanation} \\ \hline \\[-0.5em]
Variable
& \code|val x = expr|  & \Comment{Variable x is assigned to expr. A \textbf{val} can only be \textbf{assigned once}.}\\
& \code|val x: Int = 0|  & \Comment{Explicit type annotation,  expr: SomeType allowed after any expr.}\\
& \code|var x = expr|  & \Comment{Variable x is assigned to expr. A \textbf{var} can be \textbf{re-assigned}.} \\
& \code|val x, y = expr| & \Comment{Multiple initialisations, x and y is initialised to the same value.}\\
& \code|val (x, y) = (e1, e2)| & \Comment{Tuple pattern initialisation, x is assigned to e1 and y to e2.}\\
& \multicolumn{2}{l}{\code|val Seq(x, y) = Seq(e1, e2)|  \Comment{Sequence pattern initialisation, x is assigned to e1 and y to e2.}}\\
%& \code|val x: Int = _| & \Comment{Initialized to default value, 0 for number types, null for AnyRef types.}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Function
& \code|def f(a: Int, b: Int): Int = a + b| & \Comment{Function f of type (Int, Int) => Int}\\
& \code|def f(a: Int = 0, b: Int = 0): Int = a + b| & \Comment{Default arguments used if args omitted, f().}\\

&  \code|f(b = 1, a = 3)| & \Comment{{\hspace{-0.25em} Named arguments can be used in any order.}}\\
& \code|def add(a: Int)(b: Int): Int = a + b| & \Comment{Multiple parameter lists, apply: add(1)(2)} \\

& \code|(a: Int, b: Int) => a + b| & \Comment{Anonymous function value, ''lambda''.}\\
& \code|val g: (Int, Int) => Int = (a, b) => a + b| & \Comment{Types can be omitted in lambda if inferable.}\\

%& \multicolumn{2}{l}{\code|f _| \hspace{4.8em} \Comment{Replacing a parameter list with a space and underscore gives the function itself as a value.}}\\

& \multicolumn{2}{l}{\code|val inc = add(1) | \hspace{-4.25em} \Comment{\hspace{6em} Partially applied function add(1) of add above, where inc is of type Int => Int}}\\

& \multicolumn{2}{l}{\code|def addAll(xs: Int*) = xs.sum |  \Comment{\hspace{0.42em} Repeated parameters: addAll(1,2,3) or addAll(Seq(1,2,3)*) }}\\

& \multicolumn{2}{l}{\code|def twice(block: => Unit) = \{ block; block \}| \Comment{\hspace{0.5em} Call-by-name argument evaluated later.}}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Object
& \code|object Name { defsAndDecl } | \Comment{Singleton object auto-allocated when referenced the first time.}
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Class
& \code|class C(parameters) { defsAndDecl }| & \hspace{-3.2em}\Comment{A template for objects to be allocated with \textbf{new} or apply.} \\
& \code|case class C(parameters) { defsAndDecl }| & \Comment{Case class parameters become val members,} \\
& \multicolumn{2}{l}{\Comment{other case class goodies: equals, copy, hashcode, unapply, nice toString, companion object with apply factory.}}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Trait
& \code|trait T(parameters) { defsAndDecl }| & \hspace{-0.5em}\Comment{A trait is like an abstract class, but can be mixed in.}\\
& \code|class C extends D, T| & \hspace{-6.5em}\Comment{A class can only \textbf{extend} one class but \textbf{mix in} many traits separated with \code{,}}\\
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l l}\MoveUp
Type
& \code|type A = typeDef | & \Comment{Defines an alias A for the type in typeDef. Abstract if no typeDef.}
\end{tabular}

\begin{tabular}{@{}p{\FirstColWidth} l @{}l}\MoveUp
Import
& \code|import path.to.name | & \Comment{Makes name directly visible. Can be renamed using \textbf{as}}\\
& \code|import path.to.* |   & \Comment{Wildcard \code{*} imports all.}\\
& \code|import path.to.{a, b as x, c as _} | & \Comment{Import several names, b renamed to x, c not imported.}\\
\end{tabular}
}% end small

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\vspace*{-2.6em}
\head{Modifyers on definitions and declarations}\Newline

\vspace{0.25em}
{\small
\begin{tabular}{@{}l @{}l l}
\textbf{Modifier} & \textbf{applies to} & \textbf{semantics}\\ \hline \\[-0.7em]
%\code|private[this] | & definitions, declarations & \Comment{Restricts access to this instance only; also private[p] for package p.} \\
\code|private| & definitions, declarations& \Comment{Restricts access to directly enclosing class and its companion.}\\
\code|override| & definitions, declarations& \Comment{Mandatory if overriding  a concrete definition in a parent class.}\\
\code|final| &  definitions & \Comment{Final members cannot be overridden, final classes cannot be extended.}\\
\code|protected|~~ & definitions& \Comment{Restricts access to subtypes and companion.}\\
\code|lazy| & val & \Comment{Delays initialization of val, initialized when first referenced.}\\
\code|infix| & def & \Comment{Allow alpha-numeric names in operator notation without warning.}\\
\code|inline| & def, val & \Comment{Replaced at compile time by its implementation. Also if, match, params.} \\
\code|abstract| & class & \Comment{Abstract classes cannot be instantiated (redundant for traits).}\\
\code|sealed| & class, trait & \Comment{Restricts direct inheritance to classes in the same compilation unit.}\\
\code|open| & class & \Comment{Signal intent to be used in inheritance hierarchy. Silences warning.} \\
\code|transparent | & class, trait, def & \Comment{TInference of class/trait is suppressed. Inference of def type is precise.} \\
\end{tabular}
}

\vspace{0.25em}

\head{Constructors and special methods (getters, setters, apply, update, right-assoc. op.), Companion object}\Newline

{\small
\begin{tabular}{@{}l @{}l}
\code|class A(initX: Int = 0):| & \Comment{\textbf{primary constructor}, object creation (new is optional): new A(1), A(1), A()} \\
\code|  private var _x = initX| & \Comment{\textbf{private member} only visible in A and its companion object} \\
\code|  def x: Int = _x| & \Comment{\textbf{getter} for private field \_x (name with \_ chosen to avoid clash with x)} \\
\code|  def x_=(i: Int): Unit =   | & \Comment{special setter syntax of \textbf{setter} method enabling assignment syntax:} \\
\code|    _x = i  | & \code|  val a = A(1);  a.x = 2| \Comment{~~~means} \code|a.x_=(42)|\\ 
\code|  def +: (i: Int) = _x += i | & \Comment{\textbf{Right associative operator} if ends with colon:} \code|42 +: a| \Comment{~means} \code|a.+:(42)| \\ 
\code|end A| & \Comment{optional end marker checked by compiler} \\
\code|object A: | & \Comment{becomes a \textbf{companion object} if same name and in same code file} \\
\code|  def apply(i: Int) = |  & \Comment{apply is optional: A(1) is expanded to A.apply(1)} \\
\code|    new A(i) |  & \Comment{\code|new| is needed here to avoid recursive calls} \\
\code|  val y = A(1)._x | & \Comment{private members can be accessed in companion} \\
\end{tabular}


\vspace{0.5em}
\Comment{Getters and setters above are auto-generated by \textbf{var} in primary constructor:}
 {\hfill\code|class A(var x: Int = 0)|}\\
\Comment{With \textbf{val} in primary constructor only getter, no setter, is generated:}
 {\hfill\code|class A(val x: Int = 0)|} \\
\Comment{\textbf{Private constructor} e.g. to enforce use of factory in companion only:}
{\hfill\code|class A private (var x: Int = 0)|} \\
\Comment{Instead of default arguments, an \textbf{auxiliary constructor} can be defined (less common):} {\hfill\code|def this() = this(0)|}

\vspace{-0.2em}\hspace{0.32em}\begin{minipage}{0.65\linewidth}%
{\small\begin{Code}[frame=none]
class IntVec(private val xs: Array[Int]):
  def update(i: Int, x: Int): Unit = { xs(i) = x }
  def apply(i: Int): Int = xs(i)
\end{Code}%
}%
\end{minipage}%
\hfill\begin{minipage}{0.32\linewidth}
\vspace{0.5em}\raggedright{\small
\Comment{Special syntax for \textbf{update} and \textbf{apply}:} \\
v(0) = 0~\Comment{expands to} v.update(0,0)\\
v(0)\hspace{1.5em}\Comment{expands to} v.apply(0)\\
\Comment{where} val v = IntVec(Array(1,2,3)) \\

}%
\end{minipage}

}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\vspace{0.0em}\head{Type parameters, type bounds, variance, ClassTag}\vspace{0.75em}
\renewcommand{\arraystretch}{1.0}
{\small%
\begin{tabular}{@{}l @{\hspace{-10.7em}}r}
\code|class Box[T](val x: T): |
& \Comment{a \textbf{generic class} Box with a \textbf{type parameter} T, allowing x to be of any type}\\

\code|  def pair[U](y: U): (T, U) = (x, y) |
& \Comment{a \textbf{generic method} with \textbf{type parameter} U} \\

\code| |
& \Comment{T is bound to the type of x, U is free in pairedWith, so y can be of any type}\\

\code|val b = Box(0) |
& \Comment{same as (with explicit type parameters):~~~val b: Box\textbf{[Int]} = new Box\textbf{[Int]}(0)}\\

\code|val p: (Box[Int], Box[Char]) = b.pair(Box('!'))  |
& \Comment{\textbf{type bounds} \code|>:| supertype~~\code|<:| subtype}\\

\end{tabular}
}% small

\vspace{0.0em}{\small
\Comment{\code|+| \textbf{covariance}~~\code|-| \textbf{contravariance}}~~~~\code|class Box[+T](x: T){ def pair[U >: T](y: U) = (x, y) }| \\
ClassTag needed for generic array constr.: \code|def mkArr[A:reflect.ClassTag](a: A) = Array[A](a)|
}%end small





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{0.5em}\head{Expressions}\Newline
{\small\renewcommand{\arraystretch}{1.06}
\begin{tabular}{@{}l @{\hspace{0.9em}}l @{\hspace{0.2em}}l}
literals  &  \code|0 0L 0.0 "0" '0' true false|   & \Comment{Basic types e.g. Int, Long, Double, String, Char, Boolean} \\

block     &  \code|{ expr1; ...; exprN } |         &  \Comment{The value of a block is the value of its last expression}   \\
if        &  \code|if cond then expr1 else expr2 |  & \Comment{Value is expr1 if cond is true, expr2 if false (else is optional)} \\
match     &  \code|expr match caseClauses |  &  \Comment{Matches expr against each case clause, see pattern matching. } \\

for       &  \code|for x <- xs do expr |          &   \Comment{Loop for each x in xs, x visible in expr, type Unit }  \\
yield     &  \code|for x <- xs yield expr|     &   \Comment{Yields a sequence with elems of expr for each x in xs }\\
while     &  \code|while cond do expr |           &   \Comment{Loop expr while cond is true, type Unit }\\
%do while  &  \code|do expr while (cond) |        &   \Comment{Do expr at least once, then loop while cond is true, type Unit}\\
throw     &  \code|throw new Exception("Bang!") |  &  \Comment{Throws an exception that halts execution if not in try catch } \\
try       &  \code|val resultOfUnsafeExpr =  |  & \Comment{Evaluate function f: Throwable => T if exception thrown by expr} \\
          &  \code|  try expr catch f |  & \Comment{f for example: } \code|{case e: Exception => someValue}|\\
          & \code|  finally doStuff| & \Comment{finally is optional, doStuff always done even if expr throws} \\
\end{tabular}

\clearpage

\vspace*{-2.0em}\head{Expressions (continued)}\Newline
\begin{tabular}{@{}l @{\hspace{-1.6em}}r @{\hspace{0.6em}}l | r l}
  \textbf{Tuples:} & & & \multicolumn{2}{l}{\textbf{Integer division and remainder:}}\\
Empty tuple, unit value& \code|()|  &  \Comment{the only value of type Unit}  & \multicolumn{2}{l}{\code|a / b|  \Comment{~no decimals if  Int, Short, Byte }}  \\
2-tuple value   & \code|(1, "hi")| &  \Comment{also: 1->"hi" and Tuple2(1, "hi")} & \multicolumn{2}{l}{\code|a \% b|  \Comment{~fulfills: (a / b) * b + (a \% b) == a}}   \\ 
2-tuple type    & \code|(Int, String)| & \Comment{same as Tuple2[Int, String]} & \Comment{Check if x is even:} \code|x % 2 == 0|  \\[0.25em]
\end{tabular} 
\begin{tabular}{@{}l @{\hspace{-1.6em}}r @{\hspace{0.6em}}l | r l}
\multicolumn{5}{l}{\hspace{-0.7em}Tuple prepend~~~\code|3 *: (1.0, '!')| ~\Comment{of type \texttt{Int\,*:\,Double\,*:\,Char\,*:\,EmptyTuple}~~same as (Int, Double, Char)}}\\
\multicolumn{5}{l}{\hspace{-0.7em}Methods on tuples:~~\code|apply _1 _2| \Comment{...} ~ \code|drop take head init tail zip toArray toIArray toList| }\\[0.25em]
\textbf{Non-referable reference} \code|  null|  &  \multicolumn{3}{l}{\hspace{-0.7em}\Comment{refers to null object of type Null. Instead prefer Option or unitialized:} }\\
\multicolumn{5}{l}{\hspace{-0.7em}\textbf{Uninitialized} ~~~\code|var x: String = scala.compiletime.uninitialized| ~~\Comment{mutable AnyRef field set to null} } \\
\textbf{Shorthand assignment operator} \code| x += 1|  &  \multicolumn{3}{l}{\hspace{1.25em}\Comment{expands to~~\code|x = x + 1|~~if no method += is available, works for all operators}} \\[0.25em]

\end{tabular} 


\renewcommand{\arraystretch}{1.05}
\begin{tabular}{@{}l @{\hspace{-1.5em}}r @{\hspace{0.6em}}l | r l}

Evaluation order& \code| (1 + 2) * 3| & \Comment{parenthesis control order} & \multicolumn{2}{l}{\hspace{-0.2em}\textbf{Precedence} of operators starting with:}\\

Method application & \code|1.+(2)|  &  \Comment{call method + on object 1} & all letters & \textbf{lowest}\\

Operator notation  & \code|1 + 2|  &   \Comment{same as 1.+(2)} & \code+|+ \\

Conjunction  & \code|c1 && c2|  &  \Comment{true if both c1 \textbf{and} c2 true}  & \code|^|  \\
Disjunction  & \code+c1 || c2+  &  \Comment{true if at least one of c1 \textbf{or} c2 true}  & \code|&|  \\
Negation  & \code|!c|          &  \Comment{logical \textbf{not}, false if c is true}  & \code|=  !| \\

Function application  & \code|f(1, 2, 3)|  &   \Comment{same as f.apply(1,2,3)} & \code|<  >|\\

Function literal  & \code|x => x + 1|  &   \Comment{anonymous function, ''lambda''} & \code|:|\\

Object creation  & \code|new C(1,2)|  &   \Comment{class args (1,2) new is optional} & \code|+ -|\\

Self reference  & \code|this|  &  \Comment{refers to the object being defined} & \code|* / %| \\
\vspace{0.4em}

Supertype reference & \code|super.m|  &  \Comment{refers to member m of supertype} & other special chars & \textbf{highest} \\ %\cline{4-5}
\end{tabular}
}%end small
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\clearpage
%\vspace*{-2.5em}
\head{Pattern matching, type tests}\vspace{0.5em}

\vspace{0.25em}\renewcommand{\arraystretch}{1.0}
{\small%
\begin{tabular}{@{}l @{\hspace{-9.1em}}r}
\code|expr match |
& \Comment{expr is matched against patterns from top until match found, yielding the expression after =>}\\

\code|  case "hello" => expr |
& \Comment{\textbf{literal pattern} matches any value equal (in terms of ==) to the literal}\\

\code|  case x: C => expr |
& \Comment{\textbf{typed variable pattern} matches all instances of C, binding variable x to the instance} \\

\code|  case C(x, y, z) => expr |
& \Comment{\textbf{constructor pattern} matches values of the form C(x, y, z), args bound to x,y,z}\\
\code|  case (x, y, z) => expr  | & \Comment{\textbf{tuple pattern} matches tuple values, alias for constructor pattern Tuple3(x, y, z)}\\

\code|  case x +: xs => expr |
& \Comment{\textbf{sequence extractor patterns} matches head and tail, also x +: y +: z +: xs etc.} \\

\code+  case p1 | ... | pN => expr +
& \Comment{matches if at least one \textbf{pattern alternative} p1, p2 ... or pN  matches} \\

\code|  case x@pattern => expr |
& \Comment{a \textbf{pattern binder} with the @ sign binds a variable to (part of) a pattern} \\


\code|  case x => expr |
& \Comment{\textbf{untyped variable pattern} matches any value, typical ''catch all'' at bottom: \textbf{\texttt{case \_ =>}}} \\

\code|                         | & \Comment{Pattern matching on direct subtypes of a \textbf{sealed} class is checked for exhaustiveness by the compiler} \\
\end{tabular}
}% small

\vspace{0.1em}{\small \Comment{Matching with type pattern} \code| x match { case a: Int => a; case _ => 0 }| \Comment{is preferred over} \\ \Comment{explicit instance test and casting:} \code{ if x.isInstanceOf[Int] then x.asInstanceOf[Int] else 0}}





\vspace{0.5em}\head{Enumerations}

\vspace{0.9em}\renewcommand{\arraystretch}{1.0}
{\small%
\begin{tabular}{@{}l @{\hspace{0.3em}}l}
\code|enum Col:| & \Comment{Col is a sealed class, values in companion of type Col:}~~\code|Col.Red| ~ \Comment{etc.}   \\
\code|  case Red, Green, Blue| & \texttt{Col.values == Array(Col.Red, Col.Green, Col.Blue)} \\[0.25em]
%\vspace*{-0.5em}
\code|Col.Blue.ordinal| & \Comment{zero-based ordinal number, here} \texttt{2}. \Comment{The} \texttt{toString} \Comment{of} \texttt{Col.Blue} \Comment{is} \texttt{"Blue"} \\ 

\code|Col.valueOf("Red")|  & \Comment{value from String, here} \texttt{Red}, \Comment{can throw IllegalArgumentException}\\ 
\code|Col.fromOrdinal(0)|  & \Comment{value from Int, here} \texttt{Red}, \Comment{can throw NoSuchElementException}\\[0.3em] 

\code|enum Bin(val toInt: Int):| &  \Comment{\textbf{Parameterized enum}. \code|val| is needed for class param to be externally visible.}\\
\code|  case F extends Bin(-1)| & \Comment{get parameter from case value:} \code|Bin.F.toInt == -1|\\
\code|  case T extends Bin(1)| & \Comment{you can also define case members (def, val, etc) inside enums}\\

\end{tabular}\\[0.3em]

\code|enum Color(val rgb: Int):|  \hfill\Comment{\textbf{Algebraic Data Type} (ADT). Parameterized \code|case| expands to case class.}  \\
\code|  case Red   extends Color(0xFF0000)|  \hfill\Comment{The exends clause is only needed if parameters are passed.}  \\
\code|  case Green extends Color(0x00FF00)|  \hfill\Comment{0x00FF00 is a hexadecimal Int litteral, decimal value 65280}   \\
\code|  case Blue  extends Color(0x0000FF)|  \hfill\Comment{Parameter access:} \code|Color.Blue.rgb == 255| \\
\code|  case Mix(mix: Int) extends Color(mix)| \hfill\Comment{expanded to:}\\ \hfill\Comment{case class Mix(mix: Int) extends Color(mix) in companion object of trait Color(val rgb: Int)}  \\
}% small

%\vspace{0.25em}{\small The \textbf{unapply} method can be used in \textbf{extractor} pattern matching (to avoid extra class \& instance), e.g.:}
%
% \vspace{-0.5em}%
% \begin{minipage}{0.6\linewidth}%
% {\small
% \begin{Code}
% object Host {
%   def unapply(s: String): Option[String] =
%     if !s.startsWith("http://") then None
%     else s.stripPrefix("http://").split('/').headOption
% }
% \end{Code}
% }%small
% \end{minipage}%
% \begin{minipage}{0.4\linewidth}
% \vspace{-0.2em}{\hfill\raggedleft\small\Comment{
% \textbf{Extractor object}\\
% extractor must return \textbf{Option} \\ \textbf{None} gives no match in patterns\\
% \textbf{Some(x)} matches in patterns \\
% ~\\
% }}%
% \end{minipage}

% \vspace{-0.5em}{\small\code|str match { case Host(name) => ... }|  {\hfill\Comment{\textbf{Extractor pattern} leads to a call to Host.unapply(str)}}}

\clearpage 

\vspace*{-2.75em}\head{Extension methods}\Newline
{\small
\textbf{Extension methods} allow adding methods to a type after the type is defined, e.g. add a method to type String:
\vspace*{-0.5em}\begin{Code}
extension (s: String) def shoutBackwards = s.reverse.toUpperCase 
\end{Code} 
\vspace*{-0.45em} Can be called using dot notation and normal call: \code|"hej".shoutBackwards; shoutBackwards("hej")|

\vspace*{0.25em}\textbf{Collective extension methods} provide multiple extensions to the same type:
\vspace*{-0.5em}\begin{Code}
extension (xs: Seq[Double])                       // note: no trailing colon
  def mean: Double = xs.sum / xs.length           // significant indentation
  def midrange: Double = Seq(xs.max, xs.min).mean
  def +:(d: Double) = xs.appended(d)          // right-associative extension
\end{Code} 
\vspace*{-0.25em}Right associate extensions are swapped if called as non-extension: 
\vspace*{-0.5em}\begin{Code}
extension [T](xs: List[T])     // generic extension, type param before paren
  def second = xs.tail.head
\end{Code} 
\vspace*{-0.96em}\begin{Code}
extension [T: Ordering](xs: List[T]) // generic extension with context bound
  def sortedDescending = xs.reverse.sorted       // sorted requires Ordering 
\end{Code} 
}


\vspace{-0.2em}\head{Contextual abstractions, \texttt{given using summon}}\Newline 
{\small
\code|case class Config(lang: Lang); enum Lang { case En, Sv }| \hfill\Comment{assumed in examples below:} \\
\code|object Config:|  \hfill\Comment{Given values in companion have lowest priority.}  \\
\code|  given default: Config = Config(Lang.En)|  \hfill\Comment{A given instance. Name \code|default:| is optional.} \\[0.3em]
\code|def greet(name: String)(using cfg: Config) = | \hfill\Comment{Can also be \textbf{unnamed given}, \code|cfg:| is optional.}\\ 
\code|  if cfg.lang == Lang.Sv then s"hej $name"| \hfill\Comment{If unnamed then use:~} \code|  summon[Config]|\\
\code|  else "hello $name"| \hfill\Comment{where summon returns given of specified type}\\[0.3em]
The given arg can be ommited:  \code| greet("Anna")| \hfill\Comment{Compiler searches for implicit value of given type, here Config.}  \\
Explicit given: \code| greet("Anna")(using Config(Lang.sv))| \hfill\Comment{Keword} \code|using| \Comment{is needed for explicit givens.} \\
}



\vspace{0.5em}\head{scala.\{Option, Some, None\} to handle missing values }\Newline

{\small \textbf{Option[T]} is like a collection with zero or one element. \textbf{Some[T]} and \textbf{None} are subtypes of Option. }

\renewcommand{\arraystretch}{1.0}\vspace{0.25em}
{\small%


\begin{tabular}{@{}l @{\hspace{1.0em}}l}

\multicolumn{2}{l}{\hspace{-0.62em}\code|def rnd(): Option[String] = if math.random() > 0.9 then Some("bingo") else None|} \\

\code|rnd().getOrElse(expr)|
& \Comment{if rnd() == Some[T] then x else expr}\\

\code|rnd().map(f)|
& \Comment{if rnd() == Some(x) then Some(f(x)) else None}\\

\code|rnd().get|
& \Comment{if rnd() == Some[T] then x else throws NoSuchElementException}\\
\end{tabular}

\begin{tabular}{@{}l @{\hspace{1.0em}}l}
\code|rnd() match | & \Comment{a match on Option where expr1 if Some(x) or expr2 if None}\\
\code|  case Some(x) => expr1 | & \Comment{or use} \code|if rnd().isDefined then expr1 else expr2|\\
\code|  case None => expr2 | & \Comment{or use} \code|if rnd().isEmpty then expr2 else expr1|\\ 
\code|                     | & \Comment{or use} \code|if rnd().nonEmpty then expr1 else expr2|\\ 
\end{tabular}
}% small

{\small Some collection methods also work on \textbf{Option}: map, foreach, filter, toVector, flatten, flatMap, ... with None discarded.}



\vspace{0.5em}\head{scala.util.\{Either, Left, Right\} to handle errors as values
%, scala.concurrent.Future
}\Newline
\vspace*{-0.5em}\begin{Code}
def rnd(): Either[String, Int] = // normally returns Int but can report error
  if math.random() > 0.9 then Right(42) else Left("Bad") // Left wraps message
\end{Code}
\vspace{-0.25em}
{\small\renewcommand{\arraystretch}{1.0}

{\textbf{Either[E, V]} wraps a normal value or error. \textbf{Left[E]} error of type E. \textbf{Right[V]} normal value of type V.}

\begin{tabular}{@{}l @{\hspace{1.0em}}l}
  \code|rnd().isRight| & \Comment{Predicate that tests if normal value. To test if error:} \code|rnd().isLeft|\\
  \code|rnd().merge| & \Comment{Unraps any value, will get precice common supertype, here union type:} \code+ String | Int+ \\
  \code|rnd().swap| & \Comment{Turns a Right to Left and vice versa, with swapped type parameters.} \\
  \end{tabular}
  
}

{\small Some collection methods also work on \textbf{Either}: map, foreach, flatMap, ... with Left discarded. }

\clearpage


\vspace*{0.0em}\head{scala.util.\{Try, Success, Failure\} to handle exceptions as values
%, scala.concurrent.Future
}\Newline

\vspace{0.25em}
{\small\renewcommand{\arraystretch}{1.0}
{\textbf{Try[T]} is like a collection with \textbf{Success[T]} or \textbf{Failure[E]}.\hfill\code|import scala.util.{Try, Success, Failure}|}

\begin{tabular}{@{}l @{\hspace{-4.8em}}r}
\code|Try{ ...; ...; expr1 }.getOrElse(expr2)| & \Comment{evaluates to expr1 if successful or expr2 if exception} \\

\code|Try(expr1).recover{ case e: Exception => expr2 }| & \hspace{5em}\Comment{Success(expr2) if exception else Success(expr1)} \\
\end{tabular}
\code|Try(1/0) match |\\
\code|  case Success(x) => println("happy path") | \hfill\Comment{or use predicate:} \code|isSuccess|\\
\code|  case Failure(e) => println("exception") | \hfill\Comment{or use predicate:} \code|isFailure|\\
}

{\small Some collection methods also work on \textbf{Try}: map, foreach, flatMap, ... with Failure discarded. }


\vspace{0.5em}\head{scala.io.\{Source, StdIn\} to read/write from file, and standard in/out }\Newline
{\small
\Comment{\textbf{Read} string of lines from \textbf{file}, \code|fromFile| gives BufferedSource, \code|getLines| gives Iterator[String]}
\code|val source = scala.io.Source.fromFile("f.txt", "UTF-8")|  ~~~~\Comment{or \code|fromURL(adr, enc)|}
\code|val lines = try source.getLines.mkString("\n") finally source.close|
}


{\small
\vspace{0.25em}\Comment{\textbf{Read} string from \textbf{standard in} (prompt string is optional) using readLine; \textbf{write} to \textbf{standard out} using println:}
\code|val input = scala.io.StdIn.readLine("> ") | \Comment{} \\ 
\code|println(s"you wrote $input after > using ${input.length} chars")| 

\vspace{0.25em}\Comment{\textbf{Write} string to \textbf{file} after} import java.nio.file.\{Path, Paths, Files\}; import java.nio.charset.StandardCharsets.UTF\_8 \\[0.2em]

\Comment{Other common character encoding:} java.nio.charset.StandardCharsets.ISO\_8859\_1 \\\vspace{-0.5em}
\begin{Code}
def save(fileName: String, data: String): Path =
  Files.write(Paths.get(fileName), data.getBytes(UTF_8))
\end{Code}
}


\vspace{-0.1em}\head{Using the Scala toolkit: os, munit, JSON}\Newline
{\small

TODO: \texttt{https://docs.scala-lang.org/toolkit/os-intro.html}


TODO: \texttt{https://docs.scala-lang.org/toolkit/testing-suite.html}

}








\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace*{-2.5em}\head{The Scala Type System}%\Newline
\vspace{-0.5em}\includegraphics[width=1.05\textwidth,trim=12mm 0 0 0cm]{../img/hierarchy.pdf}

{\small \renewcommand{\arraystretch}{1.0}
\textbf{Number types}\\
\begin{tabular}{@{}l l @{\hspace{0.7em}}l @{\hspace{0.7em}}l @{}p{0.1em} | l l}
\textbf{name} & \textbf{\# bits} & \textbf{range} & \textbf{literal} &   & \multicolumn{2}{l}{\textbf{Methods on numbers}}\\ \cline{1-4}%\hline
& & & &\\[-0.8em]
\texttt{Byte}   &  8  & $-2^7$ ... $2^7-1$  &\texttt{0.toByte} &
& \code|x.abs| & \Comment{math.abs(x), absolute value}\\

\texttt{Short}  &  16 & $-2^{15}$ ... $2^{15}-1$ & \texttt{0.toShort}  &
& \code|x.round| & \Comment{math.round(x), to nearest Long}\\

\texttt{Char}   &  16 & $0$ ... $2^{16}-1$ & \code|'0'|~\code|'\u0030'| &
& \code|x.floor| & \Comment{math.floor(x), cut decimals}\\

\texttt{Int}    &  32 & $-2^{31}$ ... $2^{31}-1$ & \texttt{0  0xF} &
& \code|x.ceil| & \Comment{math.ceil(x), round up}\\

\texttt{Long}   &  64 & $-2^{63}$ ... $2^{63}-1$ & \texttt{0L} &
& \code|x max y| & \Comment{math.max(x, y), maximum}\\

\texttt{Float}  &  32 & ± $3.4 \cdot 10^{38}$  & \texttt{0F} &
& \code|x.toInt| & \Comment{also toByte, toChar, toDouble etc.}\\

\texttt{Double} &  64 & ± $1.8 \cdot 10^{308}$ & \texttt{0.0} &
& \code|1 to 4| & \Comment{Range.inclusive(1, 3), incl. 1,2,3}\\ 

\cline{1-4}

& & & &
 & \code|0 until 4| & \Comment{Range(0, 4), incl. 0,1,2,3}\\

 & & & & &  \code|Int.MinValue| & \Comment{least possible value of type Int}\\
 & & & & &  \code|Int.MaxValue| & \Comment{largest possible value of the Int}\\
  & & & & & \code|math.Pi|~~\code|math.E|  & \Comment{$\pi$  ~~ $e$}  \\
  & & & & &  \code|4.0.toRadians| & \Comment{also \texttt{toDegrees}}  \\

\end{tabular}
}

\Newline\vspace{-6.0em}{\small
Some methods in \code{math} same as in \code{java.lang.Math}:\\
\code|pow(x, y)| \Comment{~~$x^y$} \code|  sqrt(x)| \Comment{ $\sqrt{x}$ } \code|  exp(x)| \Comment{$e^x$} \\
\code|hypot(x, y)| \Comment{ $\sqrt{x^2 + y^2}$ } \code|log(x)| \Comment{2-based logaritm} \\
\code|sin(x) asin(x) cos(x) tan(x) atan2(x,y)|\\
\code|floorMod(x, y)| \Comment{similar to x \% y but always positive}

}\Newline\vspace{1em}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Newline\vspace{-2.5em}\head{The Scala Standard Collection Library}
{
\small\renewcommand{\arraystretch}{1.1}
\begin{multicols}{2}
\texttt{scala.collection.}
\begin{tabular}{@{}l l l}
\texttt{immutable.} & \texttt{mutable.} & methods with good performance: \\
\hline
\texttt{Vector} & \texttt{ArrayBuffer} & \texttt{head tail apply~~+: :+}\\
\texttt{List} &  \texttt{ListBuffer} &  \texttt{head tail~~+:~~::}  \\
\texttt{ArraySeq} & \texttt{ArraySeq} & \texttt{head apply} \\
\texttt{Set} & \texttt{Set} & \texttt{contains~~+~~-}\\
\texttt{Map} & \texttt{Map} & \texttt{apply~~+~~-} \\
\end{tabular}

\vspace{0.2em}

\texttt{String} and \texttt{Array} has implicit conversions that\\ make sequence methods work as for other sequences. \\

\newcommand{\NodeSkip}{0.5cm}
\begin{center}
\tikzstyle{collectiontype}=[rectangle, draw=black,  thick, anchor=north, text width=1.7cm, rectangle split, rectangle split parts = 1]
\hspace{1.5cm}\begin{tikzpicture}[node distance = \NodeSkip]
\node (Iterable) [collectiontype]  {\texttt{\centerline{Iterable}}};
\node (Seq) [collectiontype, below left = \NodeSkip and 0.05cm of Iterable,text width=1.0cm,]  {\texttt{\centerline{Seq}}};
\node (Set) [collectiontype, right = of Seq, text width=1.0cm,]  {\texttt{\centerline{Set}}};
\node (Map) [collectiontype, right = of Set, text width=1.0cm,]  {\texttt{\centerline{Map}}};
\node (Vector) [collectiontype, below left = \NodeSkip and -0.3cm of Seq, text width=1.0cm,]  {\texttt{\centerline{Vector}}};
\node (List) [collectiontype, below right = \NodeSkip and -0.6cm of Seq, text width=1.0cm,]  {\texttt{\centerline{List}}};
\node (ArraySeq) [collectiontype, below right = \NodeSkip and 0.9cm of Seq, text width=1.2cm,]  {\texttt{\centerline{ArraySeq}}};

\draw[umlarrow] (Seq.north) -- (Iterable.south west);
\draw[umlarrow] (Set.north) -- (Iterable.south);
\draw[umlarrow] (Map.north) -- (Iterable.south east);
\draw[umlarrow] (Vector.north) -- (Seq.south west);
\draw[umlarrow] (List.north) -- (Seq.south);
\draw[umlarrow] (ArraySeq.north) -- (Seq.south east);

\end{tikzpicture}
\end{center}
\end{multicols}
}

\vspace{-0.75em} 
{\small \texttt{Array} has efficient \code{update}, but strange with generics. Special \code{Array} allocation syntax: \code{new Array[Int](n)}  ~~~Prefer \code{ArraySeq} (a "normal" collection, better with generics) or \code{IArray} (an Array that cannot be updated)}

% \vspace{-0.5em}{\small Concrete implementations of \textbf{Set} include HashSet, ListSet and BitSet; collection.\textbf{SortedSet} is implemented by TreeSet.\\
% Concrete implementations of \textbf{Map} include HashMap and ListMap; collection.\textbf{SortedMap} is implemented by TreeMap.
% }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage

\vspace*{-2.0em}\head{Methods in trait \texttt{Iterable[A]}}\Newline
{\small\renewcommand{\arraystretch}{1.14}
\begin{tabular}{@{}l p{3.6cm} p{6.8cm}}
\textbf{What} & \textbf{Usage} & \textbf{Explanation} f is a function, pf is a partial funct., p is a predicate.\\ \hline
Traverse: & \texttt{xs.foreach(f)} & Executes f for every element of xs. Return type Unit.\\ \cline{1-3}

  Add: & \texttt{xs ++ ys} & A new collection with xs followed by ys (concatenation).\\\cline{1-3}

  Map:     
      & \texttt{xs.map(f)} & A new collection created by applying f to every element in xs.\\ \cline{2-3}
      & \texttt{xs.flatMap(f)} & A new collection created by applying f (which must return a collection) to all elements in xs and concatenating the results.\\ \cline{2-3}
       & \texttt{xs.collect(pf)} & A new collection created by applying the pf to every element in xs for which it is defined (undefined ignored).\\ \cline{1-3}

  Convert: & \texttt{toVector toList toSeq toBuffer toArray} & Converts a collection. Unchanged if the run-time type already matches the demanded type.\\ \cline{2-3}
   & \texttt{toSet} & Converts the collection to a set; duplicates removed.\\ \cline{2-3}
   & \texttt{toMap} & Converts a collection of key/value pairs to a map. \\ \cline{1-3}

 %& \texttt{xs copyToBuffer buf } & Copies all elements of xs to buffer buf. Return type Unit.\\ \cline{2-3}
   Array Copy:  & \texttt{xs.copyToArray(arr,s,n)} & Copies at most n elements of xs to array arr starting at index s (last two arguments are optional). Return type Unit.\\ \cline{1-3}

  Size info: & \texttt{xs.isEmpty} & Returns true if the collection xs is empty.\\ \cline{2-3}
   & \texttt{xs.nonEmpty} & Returns true if the collection xs has at least one element.\\ \cline{2-3}
   & \texttt{xs.size} & Returns an \texttt{Int} with the number of elements in xs.\\ \cline{1-3}
  Retrieval: & \texttt{xs.head xs.last} &  	The first/last element of xs (or some elem, if order undefined).\\ \cline{2-3}
      & \texttt{xs.headOption \newline xs.lastOption} & The first/last element of xs (or some element, if no order is defined) in an option value, or \texttt{None} if xs is empty.\\ \cline{2-3}
      & \texttt{xs.find(p)} & An option with the first element satisfying p, or None.\\ \cline{1-3}


  Subparts: & \texttt{xs.tail xs.init} & The rest of the collection except xs.head or xs.last.\\ \cline{2-3}
      & \texttt{xs.slice(from, to)} & The elements in from index \texttt{from} until (not including) \texttt{to}.\\ \cline{2-3}
      & \texttt{xs.take(n)} & The first n elements (or some n elements, if order undefined).\\ \cline{2-3}
      & \texttt{xs.drop(n)} & The rest of the collection except xs take n.\\ \cline{2-3}
      & \texttt{xs.takeRight(n) \newline xs dropRight n} & Similar to \texttt{take} and \texttt{drop}  but takes/drops the last n elements (or any n elements if the order is undefined).\\   \cline{1-3}
      & \texttt{xs.takeWhile(p)} & The longest prefix of elements all satisfying p.\\ \cline{2-3}
      & \texttt{xs.dropWhile(p)} & Without the longest prefix of elements that all satisfy p.\\ \cline{2-3}
      & \texttt{xs.filter(p)} & Those elements of xs that satisfy the predicate p. \\ \cline{2-3}
      & \texttt{xs.filterNot(p)} & Those elements of xs that do not satisfy the predicate p.\\ \cline{2-3}
      & \texttt{xs.splitAt(n)} &  	Split xs at n returning the pair (xs take n, xs drop n).\\ \cline{2-3}
      & \texttt{xs.span(p)} & Split xs by p into the pair (xs takeWhile p, xs.dropWhile p).\\ \cline{2-3}
      & \texttt{xs.partition(p)} & Split xs by p into the pair (xs filter p, xs.filterNot p)\\ \cline{2-3}
      & \texttt{xs.groupBy(f)} & Partition xs into a map of collections according to f.\\ \cline{1-3}


  Conditions: & \texttt{xs.forall(p)} & Returns true if p holds for all elements of xs.\\ \cline{2-3}
      & \texttt{xs.exists(p)} & Returns true if p holds for some element of xs.\\ \cline{2-3}
      & \texttt{xs.count(p)} & An \texttt{Int} with the number of elements in xs that satisfy p.\\ \cline{1-3}

  Folds: & \texttt{xs.foldLeft(z)(op) xs.foldRight(z)(op)} & Apply binary operation op between successive elements of xs, going left to right (or right to left) starting with z.\\ \cline{2-3}
      & \texttt{xs.reduceLeft(op) \newline xs.reduceRight(op)} & Similar to foldLeft/foldRight, but xs must be non-empty, starting with first element instead of z.\\ \cline{2-3}
      & \texttt{xss.flatten} & xss (a collection of collections) is reduced by concatenation.\\ \cline{2-3}
      & \texttt{xs.sum xs.product} & Calculates the sum/product of numeric elements.\\\cline{2-3}
      & \texttt{xs.min xs.max} & Finds the minimum/maximum of numeric elements.\\
      & \texttt{xs.minBy(f)~xs.maxBy(f)} & Finds the min/max of value after applying f to each element.\\\cline{2-3}
      & \texttt{xs.minOption~xs.maxOption} & ~Finds a min/max value based on implicitly available ordering.  \\
      & \texttt{xs.minByOption(f)} & Finds a min/max value after applying f to each element. \\\cline{1-3}


\end{tabular}
}


\clearpage

\vspace*{-1.75em}\head{...more methods in trait \texttt{Iterable[A]}}\Newline

{\small\renewcommand{\arraystretch}{1.1}
\begin{tabular}{@{}l p{3.4cm} p{6.8cm}}

\textbf{What} & \textbf{Usage} & \textbf{Explanation} \\ \hline

  Iterators: & \texttt{val it = xs.iterator} & An iterator \texttt{it} of type \texttt{Iterator} that yields each element one by one: \texttt{ while (it.hasNext) f(it.next)}\\   \cline{2-3}

  & \texttt{xs.grouped(size)} & An iterator yielding fixed-sized chunks of this collection.\\\cline{2-3}
  & \texttt{xs.sliding(size)} & An iterator yielding a sliding fixed-sized window of elements.\\\cline{1-3}

  Zippers: & \texttt{xs.zip(ys)} &  	An iterable of pairs of corresponding elements from xs and ys.\\   \cline{2-3}
  & \texttt{xs.zipAll(ys, x, y)} & Similar to \texttt{zip}, but the shorter sequence is extended to match the longer one by appending elements x or y.\\\cline{2-3}
  & \texttt{xs.zipWithIndex} & An iterable of pairs of elements from xs with their indices.\\\cline{1-3}

  Compare: & \texttt{xs.sameElements(ys)} & True if xs and ys contain the same elements in the same order.\\   \cline{1-3}

 Make string: & \texttt{xs.mkString(start, sep, end)} & A string with all elements of xs between separators sep enclosed in strings start and end; start, sep, end are all optional.\\ \cline{1-3}



\end{tabular}
}

\Newline
\head{Methods in trait \texttt{Seq[A]}}\Newline

{\small\renewcommand{\arraystretch}{1.1}
\begin{tabular}{@{}l p{3.75cm} p{6.8cm}}

%\textbf{What} & \textbf{Usage} & \textbf{Explanation} \texttt{f} is function, \texttt{pf} is partial funct., \texttt{p} is predicate.\\ \hline

  Indexing & \texttt{xs(i)  ~ xs.apply(i)} & The element of xs at index i.\\   \cline{2-3}

  and size: & \texttt{xs.length} & Length of sequence. Same as \texttt{size} in \texttt{Iterable}.\\\cline{2-3}
  & \texttt{xs.indices} & Returns a \texttt{Range} extending from 0 until xs.length.\\\cline{2-3}
  & \texttt{xs.isDefinedAt(i)} & True if i is contained in xs.indices.\\\cline{2-3}
  & \texttt{xs.lengthCompare(n)} & Returns -1 if xs is shorter than n, +1 if it is longer, else 0. \\\cline{1-3}


  Index & \texttt{xs.indexOf(x)} & The index of the first element in xs equal to x.\\   \cline{2-3}
  search: & \texttt{xs.lastIndexOf(x)} & The index of the last element in xs equal to x.\\\cline{2-3}
   & \texttt{xs.indexOfSlice(ys) \newline xs.lastIndexOfSlice(ys)} & The (last) index of xs such that successive elements starting from that index form the sequence ys.\\\cline{2-3}
   & \texttt{xs.indexWhere(p)} & The index of the first element in xs that satisfies p.\\\cline{2-3}
   & \texttt{xs.segmentLength(p, i)} & The length of the longest uninterrupted segment of elements in xs, starting with xs(i), that all satisfy the predicate p.\\\cline{2-3}
   & \texttt{xs.prefixLength(p)} &  	Same as \texttt{ xs.segmentLength(p, 0)}\\\cline{1-3}


  Add: & {\texttt{x~+:~xs~~~~~xs~:+~x}}  & Prepend/Append x to xs. Colon on the collection side. \\   \cline{2-3}
   & \texttt{xs.padTo(len, x)} & Append the value x to xs until length len is reached.\\\cline{1-3}


  Update: & \texttt{xs.patch(i, ys, r)} &  A copy of xs with r elements of xs replaced by ys starting at i. \\   \cline{2-3}
   & \texttt{xs.updated(i, x)} & A copy of xs with the element at index i replaced by x.\\\cline{2-3}
   & \texttt{xs(i) = x \newline xs.update(i, x)} & Only available for mutable sequences. Changes the element of xs at index i to x. Return type Unit.\\\cline{1-3}


  Sort: & \texttt{xs.sorted} & A new Seq[A] sorted using implicitly available ordering of A. \\   \cline{2-3}
   & \texttt{xs.sortWith(lt)} &  	A new Seq[A] sorted using less than lt: (A, A) => Boolean.\\\cline{2-3}
   & \texttt{xs.sortBy(f)}   &  	A new Seq[A] sorted by implicitly available ordering of B after applying f: A => B to each element.\\ \cline{1-3}


Reverse: & \texttt{xs.reverse} & A new sequence with the elements of xs in reverse order. \\   \cline{2-3}
   & \texttt{xs.reverseIterator} & An iterator yielding all the elements of xs in reverse order.\\\cline{2-3}
   & \texttt{xs.reverseMap(f)} & Similar to map in Iterable, but in reverse order.\\\cline{1-3}


  Tests: & \texttt{xs.startsWith(ys)} & True if xs starts with sequence ys. \\   \cline{2-3}
   & \texttt{xs.endsWith(ys)} & True if xs ends with sequence ys.\\\cline{2-3}
   & \texttt{xs.contains(x)} & True if xs has an element equal to x.\\\cline{2-3}
   & \texttt{xs.containsSlice(ys)} & True if xs has a contiguous subsequence equal to ys\\\cline{2-3}
   & \texttt{(xs corresponds ys)(p)} & True if corresponding elements satisfy the binary predicate p.\\\cline{1-3}

  Subparts: & \texttt{xs.intersect(ys)} & The intersection of xs and ys, preserving element order.\\\cline{2-3}
   & \texttt{xs.diff(ys)} & The difference of xs and ys, preserving element order.\\\cline{2-3}
   & \texttt{xs.union(ys)} & Same as \texttt{xs ++ ys} in Iterable.\\\cline{2-3}
   & \texttt{xs.distinct} & A subsequence of xs that contains no duplicated element.\\\cline{1-3}



\end{tabular}
}

\clearpage
%\Newline
\vspace*{-0.8em}\head{Mutation methods in trait \texttt{mutable.Buffer[A]}, \texttt{ArrayBuffer[A]}, \texttt{ListBuffer[A]}    }\Newline%
\vspace*{-0.5em}%
{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5cm}  p{6.6cm}}
\texttt{xs(i) = x~~~~~xs.update(i, x)} & Replace element at index i with x. Return type Unit.\\   \cline{1-2}

\texttt{xs.insert(i, x)~~xs.remove(i)} & Insert x at  \texttt{i}, ret. Unit. Remove elem at i, ret. removed elem.\\   \cline{1-2}

\texttt{xs.append(x)~~~~~xs~+=~x} & Insert x at end.  Return type Unit.\\   \cline{1-2}

\texttt{xs.prepend(x)~~~~x~+=:~xs} & Insert x in front.  Return type Unit.\\   \cline{1-2}

\texttt{xs -= x} & Remove first occurance of x (if exists). Returns xs itself. \\\cline{1-2}

\texttt{xs ++= ys~~~xs.addAll(ys)} & Appends all elements in ys to xs and returns xs itself. \\\cline{1-2}

\texttt{xs.clear()} & Remove all elements of xs. \\\cline{1-2}

\end{tabular}
}

\Newline
\vspace*{-0.2em}\head{Methods in trait \texttt{Set[A]}}%
\Newline\vspace*{-0.5em}%

{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5cm}  p{6.6cm}}

%\textbf{Usage} & \textbf{Explanation} \\ \hline

\texttt{xs(x)~xs.apply(x)~xs.contains(x)} & True if x is a member of xs. \\   \cline{1-2}

\texttt{xs.subsetOf(ys)} & True if xs is a subset of ys.\\\cline{1-2}

\texttt{xs~+~x~~~~~~~~~~xs - x} \newline \texttt{xs~+~(x,~y,~z)~~xs~-~(x,~y,~z)}& Returns a new set including/excluding elements. \newline Addition/subtraction can be applied to many arguments.\\   \cline{1-2}

\texttt{xs.intersect(ys)} & A new set with elements in both xs and ys. Also: \texttt{\&} \\\cline{1-2}
\texttt{xs.union(ys)} & A new set with elements in either xs or ys or both. Also: \texttt{|} \\\cline{1-2}
\texttt{xs.diff(ys)} & A new set with elements in xs that are not in ys. Also: \texttt{\&\textasciitilde} \\\cline{1-2}

\end{tabular}
}

\Newline
\vspace*{-0.2em}\head{Additional mutation methods in trait \texttt{mutable.Set[A]}}%
\Newline\vspace*{-0.5em}%
{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{4.5cm}  p{7.1cm}}

\texttt{xs~+=~x~~~~~xs~-=~x} & Returns the same set with included/excluded elements. \\   \cline{1-2}

\texttt{xs ++= ys~~~xs.addAll(ys)} & Adds all elements in ys to set xs and returns xs itself. \\\cline{1-2}

\texttt{xs.add(x)~~~xs.remove(x)} & Adds/removes x to xs and returns true if xs was mutated, else false. \\\cline{1-2}

%\texttt{xs retain p~~~xs.clear} & Keeps only elements that satisfy predicate p. Remove all.\\   \cline{1-2}
\texttt{xs(x) = b ~ xs.update(x, b)} & If b is true, adds x to xs, else removes x. Return type Unit.\\   \cline{1-2}
%\texttt{xs.clone} & Returns a new mutable set with the same elements as xs.\\   \cline{1-2}

\end{tabular}
}

\Newline
\vspace*{-0.2em}\head{Methods in trait \texttt{Map[K, V]}}%
\Newline\vspace*{-0.5em}%

{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5.0cm}  p{6.6cm}}

\texttt{ms.get(k)} & The value associated with key k an option, None if not found.\\   \cline{1-2}

\texttt{ms(k)~~~ms.apply(k)} & The value associated with key k, or exception if not found.\\   \cline{1-2}

\texttt{ms.getOrElse(k, d)} & The value associated with key k in map ms, or d if not found.\\   \cline{1-2}

\texttt{ms.isDefinedAt(k)} & True if ms contains a mapping for key k. Also: ms.contains(k) \\   \cline{1-2}


\texttt{ms + (k -> v)  ~~ ms + ((k, v))} \newline \texttt{ms.updated(k, v)} & The map containing all mappings of ms as well as the mapping k -> v from key k to value v. Also: ms + (k1 -> v1, k2 -> v2) \\   \cline{1-2}

\texttt{ms - k} & Excluding any mapping of key k. Also: ms - (k, l, m)\\   \cline{1-2}

\texttt{ms ++ ks} & The mappings of ms with the mappings of ks added/removed.\\   \cline{1-2}

\texttt{ms.keys~~ms.values~~ms.keySet} & An Iterable/Set containing each key/value in ms.\\   \cline{1-2}

\texttt{ms.view.mapValues(f).toMap} & A new Map[K, U] created by applying f: V => U to each value.\\   \cline{1-2}

\end{tabular}
}


\Newline
\vspace*{-0.2em}\head{Additional mutation methods in trait \texttt{mutable.Map[K, V]}}%
\Newline\vspace*{-0.5em}%

{\small\renewcommand{\arraystretch}{1.125}
\begin{tabular}{@{}p{5.0cm}  p{6.8cm}}

\texttt{ms(k) = v ~~ ms.update(k, v)} & Adds mapping k to v, overwriting any previous mapping of k.\\   \cline{1-2}

\texttt{ms += (k -> v) ~~~~ ms -= k} & Add or overwrite k -> v / Remove k if key exists or no effect.\\   \cline{1-2}

\texttt{ms.put(k, v) ~~ms.remove(k)}& Adds/removes mapping; returns previous value of k as an option.\\   \cline{1-2}

%\texttt{ms retain p~~~ms.clear} & Keeps mappings with a key satisfying predicate p. Remove all.\\   \cline{1-2}

\texttt{ms.mapValuesInPlace(f)} & Update all values by applying f: (K, V) => V to each pair.\\   \cline{1-2}

%\code|ms.clone| & Returns a new mutable map with the same mappings as ms.\\   \cline{1-2}

\end{tabular}
}

\vspace{0.75em}\head{Factory examples:}\Newline

{\small%
\Comment{On mutable Set, Map:} \code{toSet}, \code{toMap} \Comment{returns immutable};
\hfill\code{Vector(0,0,0)} \Comment{ same as } \code{Vector.fill(3)(0)};
\\
\code{collection.mutable.Set.empty[Int]} \Comment{ same as } \code{collection.mutable.Set[Int]()}\\
\mbox{\code{Map("se" -> "Sweden","nk" -> "Norway")} \Comment{same as }
\code{Map(("se","Sweden"),("nk","Norway"))}}\\
\code{Array.ofDim[Int](3,2)} \Comment{gives} \texttt{Array(Array(0, 0), Array(0, 0), Array(0, 0))} \Comment{same as} \texttt{Array.fill(3,2)(0)};
\texttt{ Vector.iterate(1.2, 3)(\_ + 0.5)} \Comment{gives} \texttt{Vector(1.2, 1.7, 2.2)}\\
\texttt{Vector.tabulate(3)("s" + \_) } \Comment{gives} \code{ Vector("s0", "s1", "s2")}
}




\clearpage

\Newline\head{Strings}\Newline
{\small\renewcommand{\arraystretch}{1.05}
Some methods below are from java.lang.String and some methods are implicitly added from StringOps, etc.\\ 
Strings are implictly treated as Seq[Char], so all Seq methods also work.

\vspace{0.0em}
\begin{tabular}{@{}l l}
\code|s(i)  s.apply(i)  s.charAt(i)| & \Comment{Returns the character at index i.} \\
\code|s.capitalize| & \Comment{Returns this string with first character converted to upper case.} \\
\code|s.compareTo(t)| & \Comment{Returns x where x < 0 if s < t, x > 0 if s > t, x is 0 if s == t}\\
\code|s.compareToIgnoreCase(t)| & \Comment{Similar to compareTo but not sensitive to case.}\\
\code|s.endsWith(t)| & \Comment{True if string s ends with string t.} \\
\code|s.replace(s1, s2)| & \Comment{Replace all occurances of s1 with s2 in s.} \\
\code|s.split(c)| & \Comment{Returns an array of strings split at every occurance of character c.} \\
\code|s.startsWith(t)| & \Comment{True if string s begins with string t.} \\
\code|s.stripMargin| & \Comment{Strips leading white space followed by | from each line in string.}\\
\code|s.substring(i)| & \Comment{Returns a substring of s with all charcters from index i.}\\
\code|s.substring(i, j)| & \Comment{Returns a substring of s from index i to index j-1.}\\
\code|s.toIntOption  s.toDoubleOption| & \Comment{Parses s as an Option[Int] or Option[Double] etc. None if invalid.}\\
\code|42.toString   42.0.toString| & \Comment{Converts a number to a String.}\\
\code|s.toLowerCase| & \Comment{Converts all characters to lower case.}\\
\code|s.toUpperCase| & \Comment{Converts all characters to upper case.} \\
\code|s.trim| & \Comment{Removes leading and trailing white space.}\\[0.5em]
\code|val sb = StringBuilder("")| & \Comment{En empty mutable string. (If multi-thread access use StringBuffer.)}\\
\code|sb.append("hello")| & \Comment{Append string in-place. Also for Int, Char, Boolean, etc}\\
\code|sb.insert(i, s)| & \Comment{Insert s at index i.}\\
\code|sb.delete(i)| & \Comment{Remove char at index i.}\\
\code|sb.setCharAt(i, ch)| & \Comment{Update char at index i to ch.}\\
\code|sb.toString| & \Comment{Make an immutable String copy of sb.}\\

\end{tabular}
}



\Newline\vspace*{-0.5em}

{\small\renewcommand{\arraystretch}{1.05}
\begin{tabular}{@{}p{0.7cm} l | r l}
\textbf{Escape} & \textbf{char} & \textbf{Special strings} & \\
\code|\n| & line break & \code|"hello\nworld\t!"| & \Comment{string including escape char for line break and tab}\\
\code|\t| & horisontal tab & \code|"""a "raw" string"""| & \Comment{can include quotes and span multiple lines}\\
\code|\"| & double quote '' & \code|s"x is $x"| & \Comment{\textbf{s interpolator} inserts values of existing names after} \code|$|\\
\code|\'| & single quote ' &  \code|s"x+1 is ${x+1}"|& \Comment{s interpolator evaluates expressions within}  \code|${}|\\
\code|\\| & backslash \textbackslash & \code|f"$x%5.2f"| & \Comment{format Double x to 2 decimals at least 5 chars wide}\\
\code|\u0041| &  unicode for A & \code|f"$y%5d"| & \Comment{format Int y right justified at least five chars wide}\\
\end{tabular}
}

\Newline\vspace*{-0.75em}\head{\code{scala.util.Random}}\Newline
{\small
\code{Random.nextInt(n)} \hfill \Comment{A random \code{Int} uniformly distributed from \code{0} until \code{n}, not including \code{n}.} \\
\code{Random.nextInt()} \hfill \Comment{A random \code{Int} uniformly distributed from \code{-Int.MaxValue} to \code{Int.MaxValue}.} \\
\code{Random.nextDouble()} \hfill \Comment{A random \code{Double}  uniformly distributed from \code{0.0} to \code{0.9999999999999999}.}\\
\code{Random.between(a, b)} \hfill \Comment{A random number (a, b is Int, Float or Double) uniformly distributed from a until b.}\\
\code{Random.nextPrintableChar()} \hfill \Comment{A random \code{Char} including \code{A} to \code{Z} or any other printable char (uniform dist.).}\\
\code{Random.nextGussian()} \hfill \Comment{A random \code{Double} that is \textbf{normally} distributed with mean 0 and std dev 1.}\\
\code{Random.shuffle(xs)} \hfill \Comment{Returns a new sequence with the elements in xs in any, equally likely, random order.}\\
\code{Random.setSeed(s)} \hfill \Comment{Set Random's integer seed \code{s}; sequence of next ''random'' values will be same on each run.}\\
}


\Newline\vspace*{-0.5em}\head{Reserved words}\Newline%% TODO: differentiate by color or something hard and soft keywords

{\small These words and symbols have special meaning. Can be used as identifiers if put within \verb|`|backticks\verb|`|.}
\vspace*{-0.5em}
\begin{Code}[morekeywords={macro,\_},otherkeywords={>,<-,\%,<,>:,@,:,=,\#},basicstyle=\ttfamily\fontsize{8}{9}\selectfont]
abstract as case catch class def derives do else end enum export extends extension false 
final finally for forSome given if implicit import infix inline lazy macro match new null 
object opaque open override package private protected return sealed super then this throw 
trait transparent true try type using val var while with yield
 _   :   =   =>   <-   <:   <%   >:   #   @
\end{Code}
% abstract case catch class def do else extends false final finally for
% forSome if  implicit import lazy macro match new null object override
% package private protected return sealed super this throw trait try true
% type val var while with yield  


%\input{java/java-quickref.tex}  %% REPLACED BY shorter ref on Java STD-lib below 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\renewcommand{\arraystretch}{1.0}
%\setcounter{page}{1}
\renewcommand{\LangColor}{blue}
\LangMarker{JVM}{3.5cm}{12}

\small

\LangTitle{Platform: Java Virtual Machine (JVM)}
\vspace{1em}

\code|scala-cli run hi.scala --jvm 21| \hfill\Comment{Specify explicit JVM version, here Java JDK 21 LTS} \\[0.5em]

\Newline\vspace*{-0.5em}\head{scala.jdk.CollectionConverters}\Newline\vspace*{-0.2em}

Enable \code{.asJava} and \code{.asScala} with \code{ import scala.jdk.CollectionConverters.* }
\vspace*{0.5em}

\begin{tabular}{@{}r c l}
\texttt{xs.asJava} on a \textbf{Scala} collection of type: & & \texttt{xs.asScala} on a \textbf{Java} collection of type: \\
\texttt{Iterator} &               $\longleftrightarrow$ & \texttt{java.util.Iterator} \\
\texttt{Iterable} &               $\longleftrightarrow$ & \texttt{java.lang.Iterable} \\
\texttt{Iterable} &               $\leftarrow$ & \texttt{java.util.Collection} \\
\texttt{mutable.Buffer} &         $\longleftrightarrow$  & \texttt{java.util.List} \\
\texttt{mutable.Set} &            $\longleftrightarrow$  & \texttt{java.util.Set} \\
\texttt{mutable.Map} &            $\longleftrightarrow$  & \texttt{java.util.Map} \\
\texttt{mutable.ConcurrentMap} &  $\longleftrightarrow$  & \texttt{java.util.concurrent.ConcurrentMap} \\\end{tabular}


\Newline\vspace*{-0.5em}\head{java.lang.Object, java.lang.\{Boolean, Byte, Character, Double, Float, Integer, Long, Short\}}\Newline\vspace*{-0.2em}

The class \texttt{java.lang.Object} corresponds to the Scala class \texttt{scala.AnyRef} with the following methods:\\[0.5em]
\code|def equals(other: Object): Boolean| \hfill\Comment{Type-unsafe equality test. Can be overridden.}\\
\code|def hashCode: Int| \hfill\Comment{An integer that is equal every other instance's hashCode if \code{equals(other)} is true.}\\
\code|def toString: String| \hfill\Comment{A readable String representation.}\\[0.5em]
The JVM makes a difference between primitive types and reference types. Primitive types in Java are auto-boxed by implicit conversion using e.g. \jcode{Integer.valueOf(42)} but that is transparent in Scala.

\vspace{2em}TODO 
\vspace{2em}TODO 



\head{java.lang.\{System, Thread\}}


\begin{etab}
System            & void System.exit(int status);   &  avsluta exekveringen, status != 0 om fel \\
                  & void System.currentTimeMillis   &   \\
\end{etab}

TODO Primitive main


\head{java.nio.file.\{Path, Paths, Files\}}

\vspace{2em}TODO 
\vspace{2em}TODO 

\head{java.util.Scanner}

\begin{etab}

Scanner           & Scanner(File f);                &  läser från filen f, ofta System.in \\
                  & Scanner(String s);              &  läser från strängen s \\
                  & String next();                  &  läser nästa sträng fram till whitespace \\
                  & boolean hasNext();              &  ger true om det finns mer att läsa \\
                  & int nextInt();                  &  nästa heltal; också nextDouble(), \ldots \\
                  & boolean hasNextInt();           &  också hasNextDouble(), \ldots \\
                  & String nextLine();              &  läser resten av raden
\end{etab}

\vspace{1em}TODO 
\vspace{1em}TODO 




% \head{java.io.File, FileNotFoundException, PrintWriter}
% \begin{etab}
% Läsa från fil     & \mc{Skapa en Scanner med new Scanner(new File(filename)). Ger File\-NotFoundException om filen inte finns. Sedan läser man ''som vanligt'' från scannern (nextInt och liknande).} \subsecend

% Skriva till fil   & \mc{Skapa en PrintWriter med new PrintWriter(new File(filename)). Ger FileNotFoundException om filen inte kan skapas. Sedan skriver man ''som vanligt'' på PrintWriter-objektet (println och liknande).}\subsecend

% Fånga undantag    & \mc{Så här gör man för att fånga FileNotFoundException:\\[1mm]
% \ind Scanner scan = null;\\
% \ind try $\{$\\
% \ind \ind scan = new Scanner(new File("indata.txt"));\\
% \ind $\}$ catch (FileNotFoundException e) $\{$\\
% \ind \ind \ldots\ ta hand om felet\\
% \ind $\}$}
% \end{etab}

\clearpage

\renewcommand{\LangColor}{cyan}
\LangMarker{\color{black}{Scala Native} ~~~~ \color{white}{ScalaJS} ~~~}{6.5cm}{12}

\LangTitle{Platform: ScalaJS (Javascript, DOM, npm)}
\vspace{1em}

\code|scala-cli compile hello-js.scala --js| \hfill\Comment{Compile to javascript} \\[0.5em]



\vspace{4em}TODO 
\vspace{4em}TODO 


\LangTitle{\color{gray}{Platform: Scala Native (LLVM, gcc)}}
\vspace{1em}

\code|scala-cli compile hello-native.scala --native| \hfill\Comment{Compile to a binary using LLVM and gcc} \\[0.5em]

\vspace{4em}TODO 
\vspace{4em}TODO 

\end{document}
